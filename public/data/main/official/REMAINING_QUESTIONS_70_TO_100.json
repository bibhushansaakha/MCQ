[
  {
    "id": 70,
    "question": "How is a friend function declared inside a class?",
    "options": ["By using the keyword friend before the function declaration", "By defining the function inside the class without friend keyword", "By declaring the function as public", "By declaring the function as private"],
    "correct_answer": "By using the keyword friend before the function declaration",
    "hint": "Friend functions are special functions that can access private members. How do we declare them?",
    "explanation": "A friend function is declared inside a class by using the keyword 'friend' before the function declaration. This grants the function access to the private and protected members of the class. For example: friend void display(); or friend class AnotherClass;. Friend functions are not member functions and cannot be inherited by derived classes. They break encapsulation in a controlled way when necessary.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 71,
    "question": "What happens when a derived class overrides a base class method?",
    "options": ["Base class method is called", "Derived class method replaces base class method", "Both methods run simultaneously", "Program throws an error"],
    "correct_answer": "Derived class method replaces base class method",
    "hint": "When a derived class has the same method as the base class, which one executes?",
    "explanation": "When a derived class overrides a base class method, the derived class method replaces the base class method in execution. This is called method overriding and is a key feature of polymorphism. When you call the method on a derived class object, the derived class version executes. If you want to call the base class version, you must explicitly use the scope resolution operator (BaseClass::method()). This allows subclasses to customize behavior inherited from parent classes.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 72,
    "question": "How do you declare a virtual function in C++?",
    "options": ["virtual void func();", "void virtual func();", "void func() virtual;", "void func() : virtual;"],
    "correct_answer": "virtual void func();",
    "hint": "Virtual keyword comes before the return type. What's the correct syntax?",
    "explanation": "Virtual functions are declared using the 'virtual' keyword before the return type: 'virtual void func();'. The virtual keyword enables dynamic (runtime) polymorphism. When a virtual function is called through a pointer or reference, the appropriate overridden version in the derived class is executed. Virtual functions must be member functions and cannot be static or friends. They are fundamental to implementing polymorphic behavior in C++.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 73,
    "question": "What happens if an exception is thrown but not caught?",
    "options": ["Program continues normally", "The exception is ignored", "Program crashes or terminates", "The exception is logged and ignored"],
    "correct_answer": "Program crashes or terminates",
    "hint": "Unhandled exceptions cause the program to stop. What happens to the program?",
    "explanation": "If an exception is thrown but not caught by any try-catch block, the program terminates or crashes. The exception propagates up the call stack looking for a handler. If no handler is found, the program crashes with an error. In some systems, an uncaught exception handler might log the error before terminating. Proper exception handling requires using try-catch blocks to gracefully handle errors and prevent program termination.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 74,
    "question": "The CPI (Cycles Per Instruction) in an ideal pipeline is:",
    "options": ["0", "1", "n", "Depends on clock speed"],
    "correct_answer": "1",
    "hint": "In a perfect pipeline with no stalls, how many cycles per instruction?",
    "explanation": "In an ideal pipeline with no stalls, dependencies, or hazards, the CPI (Cycles Per Instruction) is 1. This means one instruction completes per clock cycle after the initial pipeline fill. A well-designed pipeline can achieve CPI close to 1 through techniques like superscaling. However, practical pipelines have stalls due to data hazards, control hazards, and cache misses, increasing the actual CPI above 1.",
    "chapter": "Chapter 4: Computer Organization",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 75,
    "question": "Increasing cache size generally:",
    "options": ["Always improves performance", "Improves hit ratio but may increase access time", "Reduces both hit ratio and access time", "Does not affect system performance"],
    "correct_answer": "Improves hit ratio but may increase access time",
    "hint": "Larger caches have more space but may take longer to search. What's the trade-off?",
    "explanation": "Increasing cache size generally improves hit ratio (more data fits) but may increase access time (larger memory takes longer to search). There's a trade-off: a larger cache stores more data, reducing misses, but adds latency in searching for data. Optimal cache size depends on the workload and the technology used. Modern systems use multiple cache levels (L1, L2, L3) to balance these factors.",
    "chapter": "Chapter 4: Computer Organization",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 76,
    "question": "In DMA (Direct Memory Access), data transfer occurs directly between:",
    "options": ["CPU and memory", "CPU and I/O", "I/O device and memory", "Cache and registers"],
    "correct_answer": "I/O device and memory",
    "hint": "DMA allows data transfer without CPU involvement. Which two components exchange data directly?",
    "explanation": "In DMA (Direct Memory Access), data transfer occurs directly between I/O device and memory, bypassing the CPU. This improves performance by allowing the I/O controller to manage data transfer independently. The CPU is freed to do other tasks. DMA requires a DMA controller that handles address generation, data transfer, and interrupt signaling. After transfer completes, the DMA controller interrupts the CPU to indicate completion.",
    "chapter": "Chapter 4: Computer Organization",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 77,
    "question": "Which of the following is NOT a VHDL modeling style?",
    "options": ["Behavioral", "Structural", "Dataflow", "Algorithmic"],
    "correct_answer": "Algorithmic",
    "hint": "VHDL has Behavioral, Structural, and Dataflow styles. Which is NOT one?",
    "explanation": "Algorithmic is NOT a VHDL modeling style. The three main VHDL modeling styles are: (1) Behavioral - describes what the system does using processes, (2) Structural - describes how the system is built from components, (3) Dataflow - describes the flow of data through concurrent statements. 'Algorithmic' is not a distinct modeling style in VHDL, though algorithmic descriptions are often part of behavioral modeling.",
    "chapter": "Chapter 2: Digital Logic & Microprocessor",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 78,
    "question": "Which protocol provides connectionless, unreliable service?",
    "options": ["TCP", "UDP", "ICMP", "HTTP"],
    "correct_answer": "UDP",
    "hint": "UDP doesn't establish connections and doesn't guarantee delivery. This matches which protocol?",
    "explanation": "UDP (User Datagram Protocol) provides connectionless, unreliable service. Unlike TCP which establishes connections and guarantees delivery, UDP sends datagrams without connection setup and doesn't guarantee they arrive. UDP has lower overhead and latency, making it suitable for real-time applications like voice/video where speed matters more than reliability. Applications include DNS, DHCP, streaming media, and online gaming.",
    "chapter": "Chapter 5: Network & Security",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 79,
    "question": "Which command is used in Windows to view the ARP cache?",
    "options": ["ipconfig", "arp -a", "ping", "netstat"],
    "correct_answer": "arp -a",
    "hint": "ARP maps IP addresses to MAC addresses. What Windows command displays the ARP cache?",
    "explanation": "The command 'arp -a' is used in Windows to view the ARP (Address Resolution Protocol) cache. This command displays the mapping between IP addresses and MAC addresses on the local network. Ipconfig shows IP configuration. Ping tests connectivity. Netstat shows network statistics. The arp -a command helps troubleshoot network connectivity issues by showing which IP-to-MAC mappings are cached.",
    "chapter": "Chapter 5: Network & Security",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 80,
    "question": "Port number 25 is associated with which protocol?",
    "options": ["a) HTTP", "b) FTP", "c) SMTP", "d) Telnet"],
    "correct_answer": "c) SMTP",
    "hint": "Port 25 is the standard email sending port. Which protocol uses it?",
    "explanation": "Port 25 is associated with SMTP (Simple Mail Transfer Protocol), used for sending emails. HTTP uses port 80, HTTPS uses 443, FTP uses ports 20-21, Telnet uses port 23. SMTP port 25 is the default for mail servers to relay messages. Port 587 is also used for SMTP with TLS encryption. Understanding common port numbers is essential for network administration and security.",
    "chapter": "Chapter 5: Network & Security",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 81,
    "question": "What does FTP stand for?",
    "options": ["a) File Transfer Protocol", "b) Fast Transfer Process", "c) File Transmission Program", "d) File Transfer Program"],
    "correct_answer": "a) File Transfer Protocol",
    "hint": "FTP is a protocol for transferring files between computers. What's its full form?",
    "explanation": "FTP stands for File Transfer Protocol. It's a standard protocol for transferring files between computers over a network. FTP uses two connections: control connection (port 21) for commands and data connection (port 20) for actual file transfer. FTP has largely been replaced by SFTP (Secure FTP) over SSH due to security concerns. FTP transmits credentials in plain text, making it vulnerable to interception.",
    "chapter": "Chapter 5: Network & Security",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 82,
    "question": "Which layer of the OSI model does SSL (Secure Sockets Layer) operate on?",
    "options": ["a) Application", "b) Transport", "c) Network", "d) Data Link"],
    "correct_answer": "b) Transport",
    "hint": "SSL provides encryption for data in transit. Between application and network, which layer?",
    "explanation": "SSL (Secure Sockets Layer) operates on the Transport Layer (Layer 4) of the OSI model. It sits between the application layer and transport layer, providing encryption for data in transit. SSL/TLS encapsulates application layer data and encrypts it before passing to the network layer. This is why HTTPS (HTTP over SSL) provides secure web browsing. Modern systems use TLS (Transport Layer Security), the successor to SSL.",
    "chapter": "Chapter 5: Network & Security",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 83,
    "question": "In FSM (Finite State Machine), the initial state is also called:",
    "options": ["a) Final state", "b) Start state", "c) Idle state", "d) Temporary state"],
    "correct_answer": "b) Start state",
    "hint": "The state where the FSM begins its operation. What's this state called?",
    "explanation": "In an FSM (Finite State Machine), the initial state is also called the Start state. This is the state where the FSM begins its operation before processing any inputs. Every FSM has exactly one initial state (unless specified otherwise). Final or accepting states are different from the initial state. The FSM transitions from the start state based on inputs and defined transition rules.",
    "chapter": "Chapter 6: Theory, Computation & Graphics",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 84,
    "question": "In CFG (Context-Free Grammar), what does ε represent?",
    "options": ["a) Terminal", "b) Non-terminal", "c) Empty string", "d) Start symbol"],
    "correct_answer": "c) Empty string",
    "hint": "This symbol represents nothing or empty input in grammar. What is it?",
    "explanation": "In CFG (Context-Free Grammar), ε (epsilon) represents the empty string. It denotes zero-length string or no input. ε production allows a non-terminal to derive nothing, enabling optional grammar elements. For example: A → ε means non-terminal A can produce an empty string. This is useful for making parts of grammar optional without creating ambiguity.",
    "chapter": "Chapter 6: Theory, Computation & Graphics",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 85,
    "question": "The Halting Problem for Turing Machines is:",
    "options": ["a) Decidable", "b) Undecidable", "c) Always halts", "d) Only for deterministic Turing Machines"],
    "correct_answer": "b) Undecidable",
    "hint": "Can we determine if any program will halt? This fundamental problem in CS is what?",
    "explanation": "The Halting Problem for Turing Machines is Undecidable. This famous problem asks: given any program and input, can we determine if the program will halt (finish) or run forever? Alan Turing proved this is undecidable - no general algorithm exists that can solve this for all programs. This is one of the foundational results in computability theory, showing limits of computation.",
    "chapter": "Chapter 6: Theory, Computation & Graphics",
    "difficulty": "difficult",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 86,
    "question": "Vector displays directly control the:",
    "options": ["a) Brightness of each pixel", "b) Position of the electron beam", "c) Colour of the pixels only", "d) Refresh rate only"],
    "correct_answer": "b) Position of the electron beam",
    "hint": "Vector displays draw lines by controlling what? Not pixels but electron beams.",
    "explanation": "Vector displays directly control the position of the electron beam. Instead of raster (pixel-based) displays that refresh all pixels, vector displays draw lines by moving the electron beam to specific coordinates. Vectors specify endpoints, and the display draws lines directly between them. This allows efficient drawing of line-based graphics. Vector displays were common in oscilloscopes and early computer graphics. Raster displays eventually replaced them for general-purpose computing.",
    "chapter": "Chapter 6: Theory, Computation & Graphics",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 87,
    "question": "Which of the following properties is NOT preserved under shear?",
    "options": ["a) Parallelism", "b) Area", "c) Angles", "d) Collinearity"],
    "correct_answer": "c) Angles",
    "hint": "Shear transformation preserves some properties but not others. What gets changed?",
    "explanation": "Angles are NOT preserved under shear transformation. Shear preserves: (1) Parallelism - parallel lines remain parallel, (2) Area - areas of shapes are preserved, (3) Collinearity - collinear points remain collinear. However, shear does NOT preserve angles - right angles may become acute/obtuse after shearing. This is why shear is useful in graphics for creating italic/slanted text effects.",
    "chapter": "Chapter 6: Theory, Computation & Graphics",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 88,
    "question": "In a circular doubly linked list, the previous pointer of the first node points to:",
    "options": ["a) Null", "b) Last node", "c) Second node", "d) Itself"],
    "correct_answer": "b) Last node",
    "hint": "In a circular list, everything points to something (nothing is null). First node's previous?",
    "explanation": "In a circular doubly linked list, the previous pointer of the first node points to the last node. This creates a circle where the last node's next pointer also points back to the first node. This structure allows traversal in both directions without reaching a null pointer. It's useful for round-robin scheduling and playlist applications where you need to loop through elements.",
    "chapter": "Chapter 7: Data Structures & OS",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 89,
    "question": "Time complexity of Merge Sort in the best case is:",
    "options": ["a) O(n)", "b) O(n log n)", "c) O(n²)", "d) O(log n)"],
    "correct_answer": "b) O(n log n)",
    "hint": "Merge sort's performance is consistent regardless of input. What's the complexity?",
    "explanation": "The time complexity of Merge Sort in the best case is O(n log n). Unlike quick sort which has best case O(n log n) and worst case O(n²), merge sort maintains O(n log n) in all cases: best, average, and worst. This consistency makes merge sort a stable, predictable sorting algorithm. The n log n comes from dividing the array logarithmically and merging linearly at each level.",
    "chapter": "Chapter 7: Data Structures & OS",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 90,
    "question": "If mutual exclusion is not enforced, what can occur?",
    "options": ["a) Starvation", "b) Semaphore overflow", "c) Deadlock", "d) Race condition"],
    "correct_answer": "d) Race condition",
    "hint": "Without mutual exclusion, multiple processes access the same resource. What problem happens?",
    "explanation": "If mutual exclusion is not enforced, a race condition can occur. Multiple processes access shared resources simultaneously, and the final result depends on the timing of access (the 'race'). This leads to inconsistent and unpredictable behavior. Mutual exclusion ensures only one process accesses a critical section at a time. Techniques like locks, semaphores, and monitors implement mutual exclusion to prevent race conditions.",
    "chapter": "Chapter 7: Data Structures & OS",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 91,
    "question": "A page fault occurs when:",
    "options": ["a) The CPU is idle", "b) A page is not in memory", "c) Memory cache is full", "d) A process tries to access a page not in memory"],
    "correct_answer": "d) A process tries to access a page not in memory",
    "hint": "Page faults happen when a page is needed but missing. Which describes this?",
    "explanation": "A page fault occurs when a process tries to access a page not in memory (RAM). The memory management unit detects this and generates an interrupt. The OS then loads the required page from disk (virtual memory) into physical memory, possibly replacing another page. This mechanism allows systems to use more virtual memory than physical memory. Excessive page faults cause thrashing and performance degradation.",
    "chapter": "Chapter 7: Data Structures & OS",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 92,
    "question": "Agile model is most suitable for:",
    "options": ["a) Projects with fixed requirements", "b) Projects with changing requirements", "c) Small, low-risk projects only", "d) Projects without customer interaction"],
    "correct_answer": "b) Projects with changing requirements",
    "hint": "Agile emphasizes flexibility and adaptation. Which project type benefits most?",
    "explanation": "Agile model is most suitable for projects with changing requirements. Agile's iterative approach allows requirements to evolve based on feedback and changing business needs. Unlike waterfall which requires fixed upfront requirements, agile accommodates change throughout development. This makes it ideal for innovative projects, startups, and domains where requirements aren't fully understood initially. Agile involves continuous customer interaction and regular delivery of working software.",
    "chapter": "Chapter 8: Software Engineering",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 93,
    "question": "Which testing is performed after fixing defects to ensure previous functionality still works?",
    "options": ["a) Unit testing", "b) Smoke testing", "c) Acceptance testing", "d) Regression testing"],
    "correct_answer": "d) Regression testing",
    "hint": "After bug fixes, we retest to ensure we didn't break existing functionality. What's this?",
    "explanation": "Regression testing is performed after fixing defects to ensure previous functionality still works. It verifies that bug fixes don't introduce new bugs and that existing features continue functioning. Regression testing re-runs previously passing tests on modified code. It's critical after changes to maintain software quality. Automated regression test suites help catch regressions early and frequently.",
    "chapter": "Chapter 8: Software Engineering",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 94,
    "question": "Which UML diagram shows system functionality from a user perspective?",
    "options": ["a) Class Diagram", "b) Deployment Diagram", "c) Sequence Diagram", "d) Use Case Diagram"],
    "correct_answer": "d) Use Case Diagram",
    "hint": "This diagram shows interactions between users and the system. What is it?",
    "explanation": "The Use Case Diagram shows system functionality from a user perspective. It displays actors (users/external systems) and their interactions with the system through use cases (system functions). Use case diagrams help gather requirements and communicate system behavior to stakeholders. They're often the starting point for system design, identifying what the system should do from users' viewpoints.",
    "chapter": "Chapter 8: Software Engineering",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 95,
    "question": "Which principle of OOD promotes code reusability?",
    "options": ["a) Encapsulation", "b) Inheritance", "c) Abstraction", "d) Polymorphism"],
    "correct_answer": "b) Inheritance",
    "hint": "Which OOP principle allows a class to acquire properties of another class?",
    "explanation": "Inheritance promotes code reusability in OOP. A derived class inherits properties and methods from a base class, avoiding code duplication. Instead of rewriting similar code, you create a base class with common functionality and derive specialized classes from it. This reduces code size, improves maintainability, and enables polymorphic behavior. All OOP principles contribute to code quality, but inheritance directly enables reusability.",
    "chapter": "Chapter 8: Software Engineering",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 96,
    "question": "Which AI application helps in self-driving cars?",
    "options": ["a) Natural Language Processing", "b) Expert Systems", "c) Computer Vision", "d) Machine Learning"],
    "correct_answer": "c) Computer Vision",
    "hint": "Self-driving cars need to 'see' and understand the road. What AI technology enables this?",
    "explanation": "Computer Vision is the AI application that helps self-driving cars. It enables cars to perceive the environment through cameras, recognize objects, lanes, traffic signals, and obstacles. Computer vision combined with machine learning allows vehicles to make driving decisions. NLP handles text/speech, Expert Systems use rules, and general Machine Learning supports vision, but computer vision specifically addresses autonomous vehicle perception.",
    "chapter": "Chapter 9: AI & Neural Networks",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 97,
    "question": "A* search combines the features of:",
    "options": ["a) Depth-First Search and Breadth-First Search", "b) Dijkstra's Algorithm and Greedy Best-First Search", "c) Bubble Sort and Quick Sort", "d) Prim's and Kruskal's Algorithms"],
    "correct_answer": "b) Dijkstra's Algorithm and Greedy Best-First Search",
    "hint": "A* uses the cost so far (like Dijkstra) and heuristic estimate (like Greedy). Combined?",
    "explanation": "A* search combines features of Dijkstra's Algorithm and Greedy Best-First Search. A* uses f(n) = g(n) + h(n), where g(n) is actual cost from start (Dijkstra's approach) and h(n) is heuristic estimate to goal (Greedy approach). This combination provides optimal pathfinding while being more efficient than Dijkstra alone. A* is widely used in game AI, robotics, and navigation systems.",
    "chapter": "Chapter 9: AI & Neural Networks",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 98,
    "question": "Which symbol is used for negation in FOPL (First Order Predicate Logic)?",
    "options": ["a) ∧", "b) ∨", "c) ¬", "d) →"],
    "correct_answer": "c) ¬",
    "hint": "Which logical operator represents NOT? In FOPL notation?",
    "explanation": "In FOPL (First Order Predicate Logic), ¬ (negation symbol) is used for negation/NOT operation. ∧ represents AND, ∨ represents OR, → represents implication. ¬P means 'not P'. Negation is fundamental to logic for expressing negative statements and negation normal form. Combined with other operators, negation allows expressing complex logical formulas.",
    "chapter": "Chapter 9: AI & Neural Networks",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 99,
    "question": "Sentiment analysis determines:",
    "options": ["a) The grammar of text", "b) Named entities", "c) The topic of text", "d) The emotion or opinion expressed in text"],
    "correct_answer": "d) The emotion or opinion expressed in text",
    "hint": "This NLP task identifies whether text is positive, negative, or neutral. What is it?",
    "explanation": "Sentiment analysis determines the emotion or opinion expressed in text. It classifies text as positive, negative, or neutral. Applications include social media monitoring, customer feedback analysis, and product reviews. Sentiment analysis uses NLP techniques and machine learning to extract subjective information from unstructured text. It's widely used in marketing, reputation management, and customer service.",
    "chapter": "Chapter 9: AI & Neural Networks",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Model Questions"
  },
  {
    "id": 100,
    "question": "If the learning rate is too low, what is likely to happen?",
    "options": ["a) Model converges quickly", "b) Model diverges", "c) Model converges very slowly", "d) Model always overfits"],
    "correct_answer": "c) Model converges very slowly",
    "hint": "Learning rate controls step size in gradient descent. Too small a step?",
    "explanation": "If the learning rate is too low, the model converges very slowly. Gradient descent takes tiny steps toward optimal weights, requiring many iterations. While low learning rates avoid overshooting, they waste computational resources and time. Conversely, too high a learning rate causes the model to diverge (jump over optimal values). Optimal learning rate balances convergence speed with stability. Learning rate scheduling adaptively adjusts this value during training.",
    "chapter": "Chapter 9: AI & Neural Networks",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Model Questions"
  }
]
