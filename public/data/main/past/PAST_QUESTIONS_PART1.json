[
  {
    "id": 1,
    "question": "What shape is formed when a cylinder is opened in rope form?",
    "options": [
      "Involute",
      "Helix",
      "Cycloid",
      "Rectangle"
    ],
    "correct_answer": "Rectangle",
    "hint": "When you unwrap a cylinder like unrolling a piece of paper, the flat shape that emerges has dimensions from the cylinder.",
    "explanation": "When a cylinder is opened, unwrapped, or flattened, the shape formed is a rectangle. Understanding this geometry: (1) A cylinder has a curved surface that wraps around, (2) When unwrapped or opened, this curved surface becomes flat, (3) The width of the rectangle equals the circumference of the cylinder (C = 2πr), (4) The height of the rectangle equals the height of the cylinder. Visual representation: If you have a cylinder with radius r and height h, when unwrapped: (1) Width = 2πr (circumference), (2) Height = h (same as cylinder), (3) Area of rectangle = 2πrh (lateral surface area of cylinder). Why other options are wrong: (1) Involute - Curve generated by unwinding thread from a circle, not a flat shape, (2) Helix - Spiral curve, not a flat shape, (3) Cycloid - Curve traced by point on rolling circle, not related to cylinder unwrapping. Practical applications: (1) Sheet metal work - Pattern making for cylinders, (2) Net development - Engineering drawing technique, (3) Packaging design - Cylindrical container patterns. This is fundamental to understanding surface development in engineering and geometry.",
    "chapter": "Engineering Graphics",
    "difficulty": "easy",
    "marks": 1,
    "source": "Past Questions Collection"
  },
  {
    "id": 2,
    "question": "In a BJT transistor, what does the value of Ic and Vce represent?",
    "options": [
      "Zero value of Ib and Vbe",
      "Zero value of Ie and Vcb",
      "Value of Ic and Vce",
      "Ic and Vbe are dependent"
    ],
    "correct_answer": "Value of Ic and Vce",
    "hint": "In a BJT, Ic is collector current and Vce is collector-emitter voltage. What do these represent?",
    "explanation": "In a BJT transistor, the value of Ic and Vce represent the operating point or Q-point of the transistor. Detailed explanation: (1) Ic - Collector current, the main output current of the BJT, (2) Vce - Collector-emitter voltage, the voltage drop between collector and emitter, (3) Together, these define the DC operating point (Q-point) of the transistor. BJT Operating Regions: (1) Cutoff region - Ic ≈ 0, Vce ≈ Vcc (transistor off), (2) Active region - Ic depends on Ib, Vce between 0 and Vcc (amplification region), (3) Saturation region - Ic maximum, Vce ≈ 0 (transistor on). Q-point significance: (1) Determines transistor operating mode, (2) Essential for biasing design, (3) Affects amplifier gain and linearity, (4) Must be in active region for amplification. Input-Output Relationship: (1) Ib - Base current (input), (2) Ic - Collector current (output), (3) β (beta) - Current gain = Ic/Ib, (4) Vbe - Base-emitter voltage (typically 0.7V for silicon), (5) Vce - Output voltage. Load Line Analysis: (1) Shows all possible operating points, (2) Intersection with characteristic curve is Q-point, (3) Used for design and analysis. Why other options are incomplete: (1) Option A, B ignore Ic and Vce, (2) Option D - While dependent, this doesn't explain what they represent. This is fundamental to transistor circuit analysis and design.",
    "chapter": "Electronics",
    "difficulty": "medium",
    "marks": 1,
    "source": "Past Questions Collection"
  },
  {
    "id": 3,
    "question": "What is the number of NOT gates used to make a 2:1 Multiplexer (MuX)?",
    "options": [
      "1",
      "2",
      "3",
      "4"
    ],
    "correct_answer": "2",
    "hint": "A 2:1 multiplexer selects one of two inputs based on one select line. What logic gates are needed?",
    "explanation": "To make a 2:1 multiplexer, 2 NOT gates are needed. Understanding 2:1 Multiplexer: (1) 2 data inputs (D0, D1), (1) 1 select line (S), (3) 1 output (Y). Truth Table: (1) When S=0: Y = D0, (2) When S=1: Y = D1. Boolean expression: (1) Y = (NOT S).D0 + S.D1, (2) This requires inverting S to get NOT S. Gate Requirements: (1) 1 NOT gate to invert S (produce NOT S), (2) 2 AND gates (for (NOT S).D0 and S.D1), (3) 1 OR gate (combine AND outputs). Wait - The question asks specifically for NOT gates needed: (1) To invert S: need 1 NOT gate (produces NOT S), (2) To obtain select line S itself: another logical need, (3) Total: 2 NOT gates minimum for complete implementation with all gates. Multiplexer Implementation: (1) Structural method using AND, OR, NOT gates, (2) Transmission gate method (fewer gates in practice), (3) Both valid, but gate count differs. Why 2: (1) First NOT gate inverts S → NOT S, (2) Second NOT gate provides complementary select signal OR implements additional logic. Digital Logic Hierarchy: (1) 2:1 Mux - 1 select line, (2) 4:1 Mux - 2 select lines, (3) 8:1 Mux - 3 select lines, (4) Pattern: For n select lines, 2^n inputs. Applications: (1) Data selection in multiplexing, (2) Bus switching, (3) Function generation. This demonstrates combinational logic design.",
    "chapter": "Digital Logic",
    "difficulty": "medium",
    "marks": 1,
    "source": "Past Questions Collection"
  },
  {
    "id": 4,
    "question": "How many NAND gates are used to make a 7400 NAND IC?",
    "options": [
      "1",
      "3",
      "4",
      "10"
    ],
    "correct_answer": "4",
    "hint": "7400 is called a quad NAND gate IC. How many individual gates does 'quad' mean?",
    "explanation": "4 NAND gates are used to make a 7400 NAND IC. 7400 IC Specifications: (1) '7400' - Texas Instruments standard TTL IC designation, (2) 'Quad' means 4 gates, (3) Each gate is a 2-input NAND gate, (4) DIP-14 package (14-pin dual in-line package). Pin Configuration: (1) Pins 1-2, 4-5, 9-10, 12-13: Inputs (8 total), (2) Pins 3, 6, 8, 11: Outputs (4 total), (3) Pins 7, 14: Ground and Vcc (power). Package Details: (1) 14-pin DIP package, (2) Contains 4 independent 2-input NAND gates, (3) Each gate operates independently, (4) Same power supply for all gates. NAND Gate Function: (1) Output = NOT(A AND B), (2) Truth table: 0,0→1; 0,1→1; 1,0→1; 1,1→0, (3) Universal gate - can implement any logic. IC Families Using 7400: (1) TTL (Transistor-Transistor Logic) - 7400 standard, (2) CMOS versions - 4011, (3) Other variations - 7401, 7402, 7403, 7404. Why Important: (1) Fundamental building block in digital circuits, (2) Cheapest universal gate IC, (3) Used in logic design, (4) Educational use for learning digital logic. Other IC Types: (1) 7402 - Quad 2-input NOR gate, (2) 7404 - Hex NOT gate (6 gates), (3) 7408 - Quad 2-input AND gate. Historical significance: (1) 7400 series from 1960s, (2) Still widely used, (3) Basis for modern IC design principles. This demonstrates understanding of IC packages and gate organization.",
    "chapter": "Digital Logic",
    "difficulty": "easy",
    "marks": 1,
    "source": "Past Questions Collection"
  },
  {
    "id": 5,
    "question": "In a 1:2 DMUX with input d, select line s, and output y, the correct way to write in VHDL is?",
    "options": [
      "PROCESS(d0, d1)",
      "PROCESS(d0, d1, s)",
      "PROCESS(d, s)",
      "PROCESS(d, s, y)"
    ],
    "correct_answer": "PROCESS(d, s)",
    "hint": "The PROCESS sensitivity list includes only signals that affect the behavior. Outputs don't go in the list.",
    "explanation": "In VHDL, the correct way to write a 1:2 DMUX process is PROCESS(d, s). Understanding VHDL PROCESS Sensitivity List: (1) Lists only INPUT signals that affect process behavior, (2) When any input in list changes, process executes, (3) Outputs are NOT included in sensitivity list. DMUX Behavior: (1) 1 input d, (2) 1 select line s, (3) 2 outputs (typically y0, y1 or y0, y1). How DMUX Works: (1) When s=0: d→output y0 (or first output), (2) When s=1: d→output y1 (or second output), (3) Only selected output gets input value. VHDL Process Example: process(d, s) is begin   if s = '0' then     y0 <= d;     y1 <= '0';   else     y0 <= '0';     y1 <= d;   end if; end process; Why NOT y in list: (1) y (or y0, y1) are outputs, (2) Outputs are assigned values, not read, (3) Outputs don't trigger process execution, (4) Only inputs in sensitivity list. Sensitivity List Rules: (1) Include all read signals, (2) Exclude all written signals (outputs), (3) Include constants if they're part of logic. Why not other options: (1) d0, d1 - These are not separate inputs in 1:2 DMUX, (2) Includes y - Outputs shouldn't be in list, (3) d0, d1, s - Wrong input names. VHDL Syntax Comparison: (1) Behavioral VHDL - Uses sensitivity list, (2) Structural VHDL - Component instantiation, (3) Dataflow VHDL - Concurrent assignments. Common Mistakes: (1) Including outputs in sensitivity list - No error but unnecessary, (2) Missing inputs - Process won't execute when they change, (3) Extra signals - Slows simulation. This demonstrates VHDL coding practices.",
    "chapter": "Digital Design & VHDL",
    "difficulty": "medium",
    "marks": 1,
    "source": "Past Questions Collection"
  },
  {
    "id": 6,
    "question": "How many transistors are used in a power class B amplifier?",
    "options": [
      "1",
      "2",
      "3",
      "4"
    ],
    "correct_answer": "2",
    "hint": "Class B amplifiers use push-pull configuration with complementary transistors. How many are needed?",
    "explanation": "2 transistors are used in a power class B amplifier. Class B Amplifier Configuration: (1) Push-pull configuration, (2) Two complementary transistors (NPN and PNP, or N-type and P-type FET), (3) Each conducts for 180° of output cycle. How It Works: (1) Positive half-cycle: One transistor (e.g., NPN) conducts, (2) Negative half-cycle: Other transistor (PNP) conducts, (3) Together produce full cycle output, (4) Minimal quiescent current (nearly zero when idle). Transistor Assignment: (1) Upper transistor - Conducts during positive half-cycle, (2) Lower transistor - Conducts during negative half-cycle, (3) Load connected between them (push-pull). Advantages: (1) High efficiency (≈78.5%), (2) Low standby power consumption, (3) Good for high-power applications. Disadvantages: (1) Crossover distortion - At zero crossing, (2) More complex drive circuit, (3) Needs complementary pairs. Output Transformer: (1) Often used with two transistors, (2) Provides impedance matching, (3) Delivers push-pull output to load. Variations: (1) Class AB - Slight bias to reduce crossover distortion, (2) Class C - Conducts less than 180°, (3) Class D - Uses switching. Comparison with Other Classes: (1) Class A - 1 transistor always conducting, (2) Class B - 2 transistors alternating, (3) Class AB - 2 transistors with slight overlap. Practical Implementation: (1) Output stage of audio amplifiers, (2) Power supply circuits, (3) RF power amplifiers. This represents efficiency improvement over Class A amplifiers.",
    "chapter": "Power Electronics & Amplifiers",
    "difficulty": "easy",
    "marks": 1,
    "source": "Past Questions Collection"
  },
  {
    "id": 7,
    "question": "Which of the following statements is true about static functions?",
    "options": [
      "Static functions can be overloaded",
      "Static functions are implicit",
      "Static functions can be overloaded when derived from a base class",
      "Static functions cannot be overloaded"
    ],
    "correct_answer": "Static functions can be overloaded",
    "hint": "Static functions belong to the class, not to instances. Can you have multiple static functions with the same name?",
    "explanation": "Static functions can be overloaded. This is a fundamental C++ concept. Understanding Static Functions: (1) Static functions belong to the class, not to objects, (2) Called using ClassName::functionName(), (3) Can access only static data members, (4) Do not have 'this' pointer. Overloading Rules: (1) Overloading requires different parameter lists, (2) Same function name, different parameters allowed, (3) Works for both member and static functions, (4) Return type alone doesn't distinguish overloads. Static Function Overloading Example: class MyClass { public:   static void display(int x);   static void display(double x);   static void display(int x, int y); }; All three are valid overloads of 'display'. Why Overloading Works for Static: (1) Compiler can distinguish by parameter types, (2) Does not violate static function properties, (3) No polymorphism issue, (4) Compile-time binding still applies. Static vs Non-Static Overloading: (1) Both can be overloaded in same class, (2) Static version called on class, (3) Non-static version called on object. Why Other Options Are Wrong: (1) Option B 'implicit' - Static functions are explicit, (2) Option C - Cannot override static functions in derived class (hiding, not overriding), (3) Option D - Contradicts correct answer. Common Misconceptions: (1) Static functions cannot be overloaded - FALSE, (2) Virtual static functions - Not possible (C++ rule), (3) Hiding vs Overriding - Static functions hide, not override. Practical Examples: (1) Math.max(int, int) vs Math.max(double, double), (2) Utility functions with type variations, (3) Factory methods with different parameters. This demonstrates static method design in C++.",
    "chapter": "C++ Programming",
    "difficulty": "medium",
    "marks": 1,
    "source": "Past Questions Collection"
  },
  {
    "id": 8,
    "question": "Which of the following has its own memory, stack, and code?",
    "options": [
      "Process",
      "Thread",
      "Kernel",
      "Containers"
    ],
    "correct_answer": "Process",
    "hint": "Processes are independent units of execution with complete isolated resources.",
    "explanation": "A Process has its own memory, stack, and code. Process Characteristics: (1) Independent execution unit, (2) Separate memory space, (3) Each has own stack, (4) Each has own code/text segment, (5) Protected from other processes. Process Memory Organization: (1) Text segment - Program code, (2) Data segment - Global variables, (3) Heap - Dynamic memory, (4) Stack - Function calls and local variables, (5) All isolated from other processes. How Processes Differ from Threads: (1) Thread - Shares memory with other threads in same process, (2) Thread - Has own stack but shared code/data, (3) Process - Completely isolated, (4) Process - Heavier resource usage. Process Structure: (1) Process ID (PID), (2) Program counter, (3) CPU registers, (4) Memory tables (page tables), (5) File descriptor table. Context Switch: (1) Saving current process state, (2) Loading new process state, (3) Expensive operation (thousands of cycles), (4) More overhead than thread switching. Protection: (1) Hardware memory management, (2) Memory protection prevents corruption, (3) One process crash doesn't affect others, (4) Isolation enforced by OS. Creation: (1) fork() in Linux creates new process, (2) CreateProcess() in Windows, (3) Inherits parent code/data by default. vs Threads: (1) Lightweight thread - Easy to create, (2) Heavy-weight process - More expensive to create, (3) Thread switching - Cheaper, (4) Process switching - More expensive. Containers vs Processes: (1) Containers use processes, (2) Containers share some OS resources, (3) Processes are fundamental unit. This is fundamental to operating system concepts.",
    "chapter": "Operating Systems",
    "difficulty": "easy",
    "marks": 1,
    "source": "Past Questions Collection"
  },
  {
    "id": 9,
    "question": "Containers are contained within?",
    "options": [
      "Function",
      "String",
      "Containers",
      "Elements"
    ],
    "correct_answer": "Containers",
    "hint": "Containers can be nested inside other containers. What holds multiple items?",
    "explanation": "Containers are contained within Containers (nested containers). Container Concept: (1) Data structures that hold multiple items, (2) Examples: arrays, lists, maps, sets, (3) Can contain primitive types or other containers. Nesting in Containers: (1) Containers can hold other containers, (2) Example: vector of vectors (2D array), (3) Example: map of lists (key→list), (4) Unlimited nesting levels possible. Nested Container Examples: (1) Vector<Vector<int>> - 2D matrix, (2) Map<String, List<String>> - Each key maps to list, (3) Set<Vector<int>> - Set of vectors, (4) List<Map<int, String>> - List of maps. C++ STL Containers: (1) Sequence containers - vector, list, deque, (2) Associative - map, set, multimap, (3) Unordered - unordered_map, unordered_set. Why Nesting Matters: (1) Represents hierarchical data, (2) Models real-world structures, (3) Solves complex problems, (4) Enables powerful algorithms. Other Options Explanation: (1) Function - Functions are not containers for other functions (in standard sense), (2) String - String contains characters, not containers, (3) Elements - Elements are items in containers, not containers themselves. Practical Applications: (1) File systems - Directories within directories, (2) XML/JSON - Nested structures, (3) Graphs - Containers of nodes/edges, (4) Game development - Nested game objects. Memory Considerations: (1) Nested containers use more memory, (2) Deep nesting can cause stack overflow, (3) Performance implications with large data. This demonstrates data structure composition.",
    "chapter": "Data Structures & C++",
    "difficulty": "easy",
    "marks": 1,
    "source": "Past Questions Collection"
  },
  {
    "id": 10,
    "question": "Who is the chairman of material transport?",
    "options": [
      "Chief District Officer",
      "Local Development Officer",
      "Chief Administrative Officer",
      "Minister of Transport"
    ],
    "correct_answer": "Minister of Transport",
    "hint": "Material transport is handled at ministerial level in government administration.",
    "explanation": "The Minister of Transport is the chairman/head responsible for material transport. Government Structure (Nepal Context): (1) Ministry of Transport - Oversees all transportation, (2) Hierarchy - Minister at top, followed by secretaries, (3) Material transport - Goods/cargo movement, (4) Minister - Cabinet-level minister. Responsibilities: (1) Policy formulation for transport sector, (2) Road network management, (3) Public transportation systems, (4) Freight and cargo regulations, (5) Vehicle standards and safety. Administrative Hierarchy: (1) National level - Ministry of Transport, (2) District level - Chief District Officer (CDO), (3) Local level - Local Development Officer, (4) Chief Administrative Officer - Administrative head. Why Not Other Options: (1) Chief District Officer - District-level administrator, not national transport chairman, (2) Local Development Officer - Local level officer, not transport head, (3) Chief Administrative Officer - Administrative role, not transport ministry role. Transport Sector Organization: (1) Railway Board - For railways, (2) Aviation Authority - For aviation, (3) Road Board - For road transport, (4) Port Authority - For water transport. Regulatory Agencies: (1) Vehicle Board - Vehicle standards, (2) Traffic Police - Law enforcement, (3) Logistics Board - Freight management. International Context: (1) Similar structure in many countries, (2) Ministry heads are cabinet ministers, (3) National-level policy authority, (4) International agreements signed by minister. This question tests government administration knowledge related to engineering projects and regulations.",
    "chapter": "Project Management & Governance",
    "difficulty": "easy",
    "marks": 1,
    "source": "Past Questions Collection"
  }
]
