{
  "chapter": "6. Theory of Computation and Computer Graphics",
  "chapter_code": "ACtE06",
  "total_questions": 26,
  "summary": "Covers automata theory, formal languages, Turing machines, and computer graphics including 2D/3D transformations and projections.",
  "subsections": [
    {"section": "6.1 - Finite Automata and FSM", "topic_code": "ACtE0601", "question_count": 5},
    {"section": "6.2 - Context-Free Languages and PDA", "topic_code": "ACtE0602", "question_count": 4},
    {"section": "6.3 - Turing Machines and Computability", "topic_code": "ACtE0603", "question_count": 4},
    {"section": "6.4 - Graphics Hardware and Software", "topic_code": "ACtE0604", "question_count": 4},
    {"section": "6.5 - 2D Transformations", "topic_code": "ACtE0605", "question_count": 5},
    {"section": "6.6 - 3D Graphics and Projections", "topic_code": "ACtE0606", "question_count": 4}
  ],
  "questions": [
    {
      "id": 1,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What type of grammar is a PDA (Pushdown Automaton) associated with?",
      "options": ["Type 0 grammar", "Type 1 grammar", "Type 2 grammar", "Type 3 grammar"],
      "correct_answer": "Type 2 grammar",
      "hint": "Think about Chomsky hierarchy classifications",
      "explanation": "A PDA is associated with Type 2 grammar (Context-Free Grammar). In the Chomsky hierarchy: Type 0 is Recursively Enumerable, Type 1 is Context-Sensitive, Type 2 is Context-Free, and Type 3 is Regular. PDAs recognize context-free languages.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "6.2 - Context-Free Languages and PDA",
      "keywords": ["PDA", "grammar", "context-free", "Chomsky"]
    },
    {
      "id": 2,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What technique is used to check if a language is regular?",
      "options": ["Turing test", "Pumping lemma", "Halting problem", "Church-Turing thesis"],
      "correct_answer": "Pumping lemma",
      "hint": "This technique helps prove languages are non-regular",
      "explanation": "The pumping lemma is used to check if a language is regular. It states that any sufficiently long string in a regular language can be 'pumped' (a portion repeated). If a language violates the pumping lemma, it's proven non-regular.",
      "source": "Set 3 (Asojh, 2080) - Long Questions",
      "difficulty": "Hard",
      "related_section": "6.1 - Finite Automata and FSM",
      "keywords": ["pumping lemma", "regular language", "proof", "automata"]
    },
    {
      "id": 3,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a key characteristic of a Universal Turing Machine?",
      "options": ["Programmable", "Fixed function", "Analog", "Quantum"],
      "correct_answer": "Programmable",
      "hint": "A universal machine can simulate other machines",
      "explanation": "A Universal Turing Machine is programmable and can simulate any other Turing Machine using an appropriate program. This programmability is a foundational concept in theoretical computer science.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Medium",
      "related_section": "6.3 - Turing Machines and Computability",
      "keywords": ["Turing machine", "universal", "programmable"]
    },
    {
      "id": 4,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "Which test is used to determine machine intelligence?",
      "options": ["Turing test", "IQ test", "A/B test", "Unit test"],
      "correct_answer": "Turing test",
      "hint": "Named after the father of computer science",
      "explanation": "The Turing test, proposed by Alan Turing in 1950, measures a machine's ability to exhibit intelligent behavior indistinguishable from humans. If an evaluator cannot distinguish between a machine and human, the machine passes the test.",
      "source": "Set 3 (Asojh, 2080) - Long Questions",
      "difficulty": "Easy",
      "related_section": "6.3 - Turing Machines and Computability",
      "keywords": ["Turing test", "AI", "intelligence", "machine"]
    },
    {
      "id": 5,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is the halting problem?",
      "options": ["Problem of stopping a computer", "Determining if a program halts on given input", "Power consumption issue", "Memory management problem"],
      "correct_answer": "Determining if a program halts on given input",
      "hint": "Proven undecidable by Turing",
      "explanation": "The halting problem asks whether a program will terminate (halt) or run forever for a given input. It's proven to be undecidable - no algorithm can determine this for all programs and inputs.",
      "source": "Set 2 (Aasadh, 2081) - Short Questions",
      "difficulty": "Hard",
      "related_section": "6.3 - Turing Machines and Computability",
      "keywords": ["halting problem", "undecidable", "computability"]
    },
    {
      "id": 6,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a finite automaton?",
      "options": ["A machine with finite memory and states", "An infinite state machine", "A quantum computer", "A random number generator"],
      "correct_answer": "A machine with finite memory and states",
      "hint": "FA has limited states and no external memory",
      "explanation": "A finite automaton is an abstract computing device with a finite number of states. It reads input symbols and transitions between states deterministically (DFA) or non-deterministically (NFA). FAs recognize regular languages.",
      "source": "Set 1 (Chaitra, 2080) - Long Questions",
      "difficulty": "Easy",
      "related_section": "6.1 - Finite Automata and FSM",
      "keywords": ["finite automaton", "DFA", "NFA", "state machine"]
    },
    {
      "id": 7,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "Which transformation resizes an object?",
      "options": ["Translation", "Rotation", "Scaling", "Shearing"],
      "correct_answer": "Scaling",
      "hint": "Think about operations like zoom in/out",
      "explanation": "Scaling is the transformation that resizes an object. It involves multiplying coordinates by scaling factors. When the factor > 1, object enlarges; when < 1, it shrinks. Scaling can be uniform or non-uniform.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Easy",
      "related_section": "6.5 - 2D Transformations",
      "keywords": ["scaling", "transformation", "zoom", "resize"]
    },
    {
      "id": 8,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What are the three basic 2D transformations?",
      "options": ["Translation, Rotation, Scaling", "Translation, Reflection, Shearing", "Only translation and rotation", "Scaling and skewing"],
      "correct_answer": "Translation, Rotation, Scaling",
      "hint": "TRS - the fundamental transformations",
      "explanation": "The three basic 2D transformations are Translation (moving), Rotation (turning), and Scaling (resizing). Other transformations like reflection and shearing can be derived or combined from these basic ones.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Easy",
      "related_section": "6.5 - 2D Transformations",
      "keywords": ["transformation", "translation", "rotation", "scaling"]
    },
    {
      "id": 9,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "On which plane does 2D rotation occur?",
      "options": ["3D plane", "2D plane", "XY plane", "XZ plane"],
      "correct_answer": "XY plane",
      "hint": "2D means two dimensions",
      "explanation": "2D rotation occurs on the XY plane. In 2D graphics, rotation is performed around a point in the XY plane, typically the origin. The rotation matrix operates on x and y coordinates.",
      "source": "Set 2 (Aasadh, 2081) - Short Questions",
      "difficulty": "Easy",
      "related_section": "6.5 - 2D Transformations",
      "keywords": ["2D rotation", "XY plane", "coordinate system"]
    },
    {
      "id": 10,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the 2D rotation matrix for angle θ?",
      "options": ["[cosθ -sinθ; sinθ cosθ]", "[cosθ sinθ; -sinθ cosθ]", "[sinθ cosθ; cosθ -sinθ]", "[1 θ; θ 1]"],
      "correct_answer": "[cosθ -sinθ; sinθ cosθ]",
      "hint": "Standard rotation matrix for 2D transformations",
      "explanation": "The 2D rotation matrix for counterclockwise rotation by angle θ is [[cosθ, -sinθ], [sinθ, cosθ]]. This matrix rotates a point (x,y) to a new position (x',y') by angle θ around the origin.",
      "source": "Set 1 (Chaitra, 2080) - Long Questions",
      "difficulty": "Hard",
      "related_section": "6.5 - 2D Transformations",
      "keywords": ["rotation matrix", "transformation", "trigonometry", "linear algebra"]
    },
    {
      "id": 11,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is perspective projection?",
      "options": ["Objects closer appear larger than those farther", "All objects same size regardless of distance", "Only 2D projection", "Projection without depth"],
      "correct_answer": "Objects closer appear larger than those farther",
      "hint": "Mimics how human eyes see reality",
      "explanation": "Perspective projection is a projection method where objects closer to the viewer appear larger and those farther appear smaller, creating a realistic 3D effect. This mimics human vision and is widely used in computer graphics.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Easy",
      "related_section": "6.6 - 3D Graphics and Projections",
      "keywords": ["perspective projection", "3D", "depth", "realism"]
    },
    {
      "id": 12,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What are the types of perspective projection?",
      "options": ["One-point, two-point, and three-point perspective", "One-point and two-point only", "Only one-point perspective", "Orthogonal projections"],
      "correct_answer": "One-point, two-point, and three-point perspective",
      "hint": "Based on the number of vanishing points",
      "explanation": "The types of perspective projection are: one-point (one vanishing point), two-point (two vanishing points), and three-point (three vanishing points). One-point is for frontal views, two-point for corners, and three-point for aerial views.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "6.6 - 3D Graphics and Projections",
      "keywords": ["perspective", "vanishing point", "projection", "3D"]
    },
    {
      "id": 13,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is orthographic projection?",
      "options": ["Perspective-based projection", "Parallel projection without perspective effect", "Projection with vanishing points", "Random projection"],
      "correct_answer": "Parallel projection without perspective effect",
      "hint": "Objects maintain size regardless of distance",
      "explanation": "Orthographic projection is a parallel projection where the projection lines are perpendicular to the projection plane. Objects maintain their size and shape regardless of distance, commonly used in technical drawings.",
      "source": "Set 2 (Aasadh, 2081) - Short Questions",
      "difficulty": "Medium",
      "related_section": "6.6 - 3D Graphics and Projections",
      "keywords": ["orthographic projection", "parallel", "technical drawing"]
    },
    {
      "id": 14,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the difference between DFA and NFA?",
      "options": ["DFA is deterministic (one transition per input), NFA is non-deterministic (multiple transitions)", "NFA is always faster", "They are equivalent", "DFA has more states"],
      "correct_answer": "DFA is deterministic (one transition per input), NFA is non-deterministic (multiple transitions)",
      "hint": "Determinism vs non-determinism in state transitions",
      "explanation": "DFA (Deterministic Finite Automaton) has exactly one transition for each input symbol from each state. NFA (Non-deterministic Finite Automaton) can have multiple transitions for the same input. Both recognize regular languages, but NFA can be more concise.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "6.1 - Finite Automata and FSM",
      "keywords": ["DFA", "NFA", "deterministic", "non-deterministic", "automata"]
    },
    {
      "id": 15,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a parse tree?",
      "options": ["A tree showing derivation of a string from grammar", "A binary search tree", "A compiler data structure", "A memory allocation structure"],
      "correct_answer": "A tree showing derivation of a string from grammar",
      "hint": "Shows how grammar rules generate strings",
      "explanation": "A parse tree (or derivation tree) shows how a string is derived from grammar rules. Each internal node represents a grammar rule, and leaf nodes represent terminal symbols. It visualizes the structure of a syntactically valid string.",
      "source": "Set 1 (Chaitra, 2080) - Short Questions",
      "difficulty": "Medium",
      "related_section": "6.2 - Context-Free Languages and PDA",
      "keywords": ["parse tree", "grammar", "derivation", "syntax tree"]
    },
    {
      "id": 16,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is Chomsky hierarchy?",
      "options": ["Classification of formal languages by generative power", "Computer organization hierarchy", "Memory hierarchy", "Processing hierarchy"],
      "correct_answer": "Classification of formal languages by generative power",
      "hint": "4 levels of language classes",
      "explanation": "The Chomsky hierarchy classifies formal grammars and languages into 4 types by generative power: Type 0 (Recursively Enumerable), Type 1 (Context-Sensitive), Type 2 (Context-Free), and Type 3 (Regular). Each type is more restrictive than the previous.",
      "source": "Set 2 (Aasadh, 2081) - Long Questions",
      "difficulty": "Hard",
      "related_section": "6.2 - Context-Free Languages and PDA",
      "keywords": ["Chomsky hierarchy", "grammar", "language class", "formal language"]
    },
    {
      "id": 17,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is graphics rendering?",
      "options": ["Storing images in memory", "Process of generating image from 3D model", "Displaying text on screen", "Memory management"],
      "correct_answer": "Process of generating image from 3D model",
      "hint": "Converts 3D data to 2D display",
      "explanation": "Graphics rendering is the process of generating a 2D image from 3D models. It involves transformations, lighting calculations, texture mapping, and rasterization to create the final image displayed on screen.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Easy",
      "related_section": "6.4 - Graphics Hardware and Software",
      "keywords": ["rendering", "graphics", "3D to 2D", "image generation"]
    },
    {
      "id": 18,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a graphics pipeline?",
      "options": ["Sequence of processing stages for rendering", "Memory bus for graphics", "Network for graphics", "Storage for images"],
      "correct_answer": "Sequence of processing stages for rendering",
      "hint": "Stages: vertex, geometry, rasterization, fragment, output",
      "explanation": "A graphics pipeline is the sequence of processing stages that convert 3D model data into a 2D image. Typical stages include vertex processing, geometry processing, rasterization, fragment processing, and output merging.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "6.4 - Graphics Hardware and Software",
      "keywords": ["graphics pipeline", "rendering", "GPU", "stages"]
    },
    {
      "id": 19,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is shading in computer graphics?",
      "options": ["Darkening an image", "Determining color of pixels based on lighting", "Creating shadows", "Color adjustment"],
      "correct_answer": "Determining color of pixels based on lighting",
      "hint": "Lighting and material interaction",
      "explanation": "Shading is the process of determining the color of pixels based on lighting conditions, material properties, and surface normals. Common shading models include Gouraud shading and Phong shading.",
      "source": "Set 1 (Chaitra, 2080) - Short Questions",
      "difficulty": "Medium",
      "related_section": "6.4 - Graphics Hardware and Software",
      "keywords": ["shading", "lighting", "Phong", "material"]
    },
    {
      "id": 20,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the difference between raster and vector graphics?",
      "options": ["Raster uses pixels, vector uses mathematical curves", "Vector is always better", "They are the same", "Raster is always scalable"],
      "correct_answer": "Raster uses pixels, vector uses mathematical curves",
      "hint": "Resolution-dependent vs resolution-independent",
      "explanation": "Raster graphics use pixels (picture elements) arranged in a grid. Vector graphics use mathematical equations to define shapes and curves. Raster is resolution-dependent; vector is scalable without quality loss.",
      "source": "Set 2 (Aasadh, 2081) - Long Questions",
      "difficulty": "Easy",
      "related_section": "6.4 - Graphics Hardware and Software",
      "keywords": ["raster", "vector", "pixels", "curves", "scalable"]
    },
    {
      "id": 21,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is texture mapping in graphics?",
      "options": ["Applying surface patterns to 3D objects", "Memory mapping technique", "Data structure mapping", "Network mapping"],
      "correct_answer": "Applying surface patterns to 3D objects",
      "hint": "Adds detail without increasing geometry",
      "explanation": "Texture mapping is the technique of applying 2D images (textures) onto 3D model surfaces. This adds visual detail and realism without increasing geometric complexity.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Medium",
      "related_section": "6.4 - Graphics Hardware and Software",
      "keywords": ["texture mapping", "3D graphics", "surface", "detail"]
    },
    {
      "id": 22,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is homogeneous coordinates in computer graphics?",
      "options": ["Coordinate system with added dimension for projective transformations", "Coordinates that are equal", "Only for 2D graphics", "Memory addressing scheme"],
      "correct_answer": "Coordinate system with added dimension for projective transformations",
      "hint": "Extends 3D coordinates to 4D",
      "explanation": "Homogeneous coordinates add an extra dimension to coordinates to represent 3D points in 4D space. This allows all transformations (translation, rotation, scaling) to be represented as matrix multiplications, simplifying graphics computations.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Hard",
      "related_section": "6.5 - 2D Transformations",
      "keywords": ["homogeneous coordinates", "projective", "transformation", "matrix"]
    },
    {
      "id": 23,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a context-free grammar?",
      "options": ["Grammar with restrictions on production rules", "Grammar without context dependency", "Grammar for regular languages", "Grammar for natural languages"],
      "correct_answer": "Grammar without context dependency",
      "hint": "Left side of productions has single non-terminal",
      "explanation": "A context-free grammar (CFG) is a formal grammar where each production rule has a single non-terminal on the left side. The right side can be any combination of terminals and non-terminals. CFGs generate context-free languages.",
      "source": "Set 1 (Chaitra, 2080) - Short Questions",
      "difficulty": "Medium",
      "related_section": "6.2 - Context-Free Languages and PDA",
      "keywords": ["context-free grammar", "CFG", "production rule", "language"]
    },
    {
      "id": 24,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a state diagram?",
      "options": ["Visual representation of FSM states and transitions", "Circuit diagram", "Data flow diagram", "Class diagram"],
      "correct_answer": "Visual representation of FSM states and transitions",
      "hint": "Shows states as circles and transitions as arrows",
      "explanation": "A state diagram is a visual representation of a finite state machine. States are shown as circles, and transitions between states are shown as labeled arrows indicating input symbols that trigger the transitions.",
      "source": "Set 2 (Aasadh, 2081) - Long Questions",
      "difficulty": "Easy",
      "related_section": "6.1 - Finite Automata and FSM",
      "keywords": ["state diagram", "FSM", "transition", "visualization"]
    },
    {
      "id": 25,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is aliasing in computer graphics?",
      "options": ["Creating alternative names", "Jagged edges in digital images due to insufficient sampling", "Memory addressing", "File organization"],
      "correct_answer": "Jagged edges in digital images due to insufficient sampling",
      "hint": "Visual artifact from pixelization",
      "explanation": "Aliasing is a visual artifact that appears as jagged or stair-stepped edges in digital images. It occurs when the sampling frequency is too low to accurately represent the original image. Anti-aliasing techniques reduce this effect.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "6.4 - Graphics Hardware and Software",
      "keywords": ["aliasing", "anti-aliasing", "sampling", "artifact"]
    },
    {
      "id": 26,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is depth buffering (Z-buffer) in graphics?",
      "options": ["Technique to handle occlusion by storing depth values", "Memory buffer for color", "Animation technique", "Compression method"],
      "correct_answer": "Technique to handle occlusion by storing depth values",
      "hint": "Determines which object is in front",
      "explanation": "Depth buffering (Z-buffer) is a technique that stores depth (distance from camera) for each pixel. When rendering overlapping objects, only the object with the smallest depth value is displayed, correctly handling occlusion.",
      "source": "Set 3 (Asojh, 2080) - Long Questions",
      "difficulty": "Hard",
      "related_section": "6.4 - Graphics Hardware and Software",
      "keywords": ["depth buffering", "Z-buffer", "occlusion", "3D rendering"]
    }
  ]
}
