{
  "chapter": "7. Data Structures and Algorithm, Database System and Operating System",
  "chapter_code": "ACtE07",
  "total_questions": 50,
  "summary": "Comprehensive coverage of data structures, algorithms, database systems, SQL, transactions, and operating system concepts.",
  "subsections": [
    {"section": "7.1 - Linear Data Structures", "topic_code": "ACtE0701", "question_count": 8},
    {"section": "7.2 - Trees and Graphs", "topic_code": "ACtE0702", "question_count": 9},
    {"section": "7.3 - Sorting and Searching", "topic_code": "ACtE0703", "question_count": 8},
    {"section": "7.4 - Database Fundamentals and SQL", "topic_code": "ACtE0704", "question_count": 10},
    {"section": "7.5 - Operating System Basics", "topic_code": "ACtE0705", "question_count": 8},
    {"section": "7.6 - Process and Memory Management", "topic_code": "ACtE0706", "question_count": 7}
  ],
  "questions": [
    {
      "id": 1,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is the maximum number of nodes a binary tree can have based on height h?",
      "options": ["2^h", "2^h - 1", "2^(h+1) - 1", "2^(h-1)"],
      "correct_answer": "2^h - 1",
      "hint": "Consider a complete binary tree",
      "explanation": "A binary tree of height h can have at most 2^h - 1 nodes when completely filled. This is calculated by summing nodes at each level: 2^0 + 2^1 + ... + 2^(h-1) = 2^h - 1.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "7.2 - Trees and Graphs",
      "keywords": ["binary tree", "height", "nodes", "complete tree"]
    },
    {
      "id": 2,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "In demand paging memory, with page fault service time 1000ms and memory access 10ms, what is effective access time for fault rate 0.01?",
      "options": ["12.9ms", "20.9ms", "19.9ms", "0.01ms"],
      "correct_answer": "19.9ms",
      "hint": "EAT = (1-p)*m + p*f",
      "explanation": "Using EAT formula: EAT = (1-0.01)*10 + 0.01*1000 = 9.9 + 10 = 19.9ms. The effective access time accounts for both successful and failed memory accesses.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Hard",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["paging", "memory", "effective access time", "fault"]
    },
    {
      "id": 3,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "Which SQL command removes content without altering table structure?",
      "options": ["DROP", "TRUNCATE", "DELETE", "REMOVE"],
      "correct_answer": "DELETE",
      "hint": "Can remove specific rows based on conditions",
      "explanation": "DELETE removes one or more rows based on WHERE conditions, keeping table structure intact. DROP removes the entire table including structure.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Easy",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["DELETE", "SQL", "DML", "table structure"]
    },
    {
      "id": 4,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What does software quality management consist of?",
      "options": ["SQA and SQC", "SQA and SQM", "SQM and SQC", "SQP and SQA"],
      "correct_answer": "SQA and SQC",
      "hint": "SQA = Assurance, SQC = Control",
      "explanation": "Software quality management comprises SQA (Software Quality Assurance - prevention) and SQC (Software Quality Control - detection). Together they ensure software meets quality standards.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "7.5 - Operating System Basics",
      "keywords": ["SQA", "SQC", "quality management", "software"]
    },
    {
      "id": 5,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a stack?",
      "options": ["Unordered collection", "LIFO (Last-In-First-Out) data structure", "FIFO structure", "Random access structure"],
      "correct_answer": "LIFO (Last-In-First-Out) data structure",
      "hint": "Last element added is first to be removed",
      "explanation": "A stack is a LIFO data structure where the last element inserted is the first to be removed. Common operations are push (add) and pop (remove).",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Easy",
      "related_section": "7.1 - Linear Data Structures",
      "keywords": ["stack", "LIFO", "push", "pop", "data structure"]
    },
    {
      "id": 6,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a queue?",
      "options": ["FIFO (First-In-First-Out) data structure", "LIFO structure", "Random access", "Sorted collection"],
      "correct_answer": "FIFO (First-In-First-Out) data structure",
      "hint": "First element added is first to be removed",
      "explanation": "A queue is a FIFO data structure where elements are added at rear and removed from front. It's commonly used in task scheduling, print spooling, and breadth-first search.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Easy",
      "related_section": "7.1 - Linear Data Structures",
      "keywords": ["queue", "FIFO", "enqueue", "dequeue", "data structure"]
    },
    {
      "id": 7,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a linked list?",
      "options": ["Array of elements", "Collection of nodes with pointers", "Sorted list", "Static allocation"],
      "correct_answer": "Collection of nodes with pointers",
      "hint": "Dynamic data structure with pointers",
      "explanation": "A linked list is a data structure where each element (node) contains data and a pointer to the next node. It allows dynamic memory allocation and efficient insertion/deletion.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Easy",
      "related_section": "7.1 - Linear Data Structures",
      "keywords": ["linked list", "node", "pointer", "dynamic allocation"]
    },
    {
      "id": 8,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the time complexity of linear search?",
      "options": ["O(1)", "O(log n)", "O(n)", "O(n^2)"],
      "correct_answer": "O(n)",
      "hint": "Must check each element in worst case",
      "explanation": "Linear search has O(n) time complexity because in worst case it must check all n elements sequentially. Average case is O(n/2) which simplifies to O(n).",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "7.3 - Sorting and Searching",
      "keywords": ["linear search", "time complexity", "O(n)"]
    },
    {
      "id": 9,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is the time complexity of binary search?",
      "options": ["O(1)", "O(log n)", "O(n)", "O(n^2)"],
      "correct_answer": "O(log n)",
      "hint": "Divides search space in half each iteration",
      "explanation": "Binary search has O(log n) complexity because it eliminates half of remaining elements each iteration. Requires array to be sorted.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "7.3 - Sorting and Searching",
      "keywords": ["binary search", "O(log n)", "logarithmic"]
    },
    {
      "id": 10,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "Which sorting algorithm has worst case O(n^2) but best case O(n)?",
      "options": ["Bubble sort", "Quick sort", "Merge sort", "Insertion sort"],
      "correct_answer": "Insertion sort",
      "hint": "Best for nearly sorted arrays",
      "explanation": "Insertion sort has O(n) best case (already sorted) and O(n^2) worst case (reverse sorted). It's efficient for small arrays and nearly sorted data.",
      "source": "Model Set",
      "difficulty": "Medium",
      "related_section": "7.3 - Sorting and Searching",
      "keywords": ["insertion sort", "time complexity", "sorting algorithm"]
    },
    {
      "id": 11,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is database normalization?",
      "options": ["Organizing data", "Process of organizing data to minimize redundancy", "Encryption method", "Backup technique"],
      "correct_answer": "Process of organizing data to minimize redundancy",
      "hint": "Reduces data duplication and improves integrity",
      "explanation": "Database normalization is a systematic approach to organizing data to reduce redundancy and improve data integrity. It involves dividing larger tables into smaller related tables.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["normalization", "redundancy", "data integrity", "database"]
    },
    {
      "id": 12,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What are the main normal forms in database design?",
      "options": ["1NF, 2NF, 3NF, BCNF", "Only 3NF", "NF1, NF2", "Unnormalized and Normalized"],
      "correct_answer": "1NF, 2NF, 3NF, BCNF",
      "hint": "Progressive levels of data organization",
      "explanation": "Main normal forms: 1NF (atomic values), 2NF (no partial dependencies), 3NF (no transitive dependencies), BCNF (stricter 3NF). Each level progressively eliminates different types of anomalies.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Hard",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["1NF", "2NF", "3NF", "BCNF", "normalization"]
    },
    {
      "id": 13,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a transaction in databases?",
      "options": ["Data transfer", "Sequence of operations that must be atomic", "Backup operation", "Query execution"],
      "correct_answer": "Sequence of operations that must be atomic",
      "hint": "All-or-nothing property (ACID)",
      "explanation": "A transaction is a sequence of database operations that must be executed atomically (all succeed or all fail). Transactions ensure data consistency through ACID properties.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["transaction", "ACID", "atomic", "database"]
    },
    {
      "id": 14,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What are ACID properties of transactions?",
      "options": ["Atomicity, Consistency, Isolation, Durability", "Addition, Consistency, Input, Data", "Always, Check, Integrate, Deliver", "Attributes, Characteristics, Issues, Details"],
      "correct_answer": "Atomicity, Consistency, Isolation, Durability",
      "hint": "Four fundamental database transaction properties",
      "explanation": "ACID properties: Atomicity (all-or-nothing), Consistency (valid state), Isolation (independent execution), Durability (permanent after commit). They ensure reliable transactions.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["ACID", "Atomicity", "Consistency", "Isolation", "Durability"]
    },
    {
      "id": 15,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a primary key in database?",
      "options": ["Main key for security", "Unique identifier for each row", "First column", "Encryption key"],
      "correct_answer": "Unique identifier for each row",
      "hint": "Must be unique and not null",
      "explanation": "A primary key is a column (or combination of columns) that uniquely identifies each row in a table. It must be unique and cannot contain NULL values.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Easy",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["primary key", "unique identifier", "database", "constraint"]
    },
    {
      "id": 16,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a foreign key?",
      "options": ["Key from another country", "Reference to primary key in another table", "Duplicate key", "Security key"],
      "correct_answer": "Reference to primary key in another table",
      "hint": "Maintains referential integrity",
      "explanation": "A foreign key is a column that references the primary key of another table. It maintains referential integrity by ensuring values exist in the referenced table.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["foreign key", "referential integrity", "relationship", "database"]
    },
    {
      "id": 17,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a process in operating systems?",
      "options": ["Hardware component", "Program in execution", "Memory location", "Disk operation"],
      "correct_answer": "Program in execution",
      "hint": "Active instance of a program",
      "explanation": "A process is a program in execution. It includes the program code, current state, stack, heap, and other resources needed for execution.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Easy",
      "related_section": "7.5 - Operating System Basics",
      "keywords": ["process", "program", "execution", "OS"]
    },
    {
      "id": 18,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What term is used for multiple processes executing concurrently in single-user system?",
      "options": ["Multiprocessing", "Multitasking", "Multithreading", "Time-sharing"],
      "correct_answer": "Multitasking",
      "hint": "Single processor, multiple tasks",
      "explanation": "Multitasking allows multiple processes to execute seemingly simultaneously on a single-user system through rapid context switching. It differs from multiprocessing (multiple processors).",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "7.5 - Operating System Basics",
      "keywords": ["multitasking", "multithreading", "context switch", "OS"]
    },
    {
      "id": 19,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a process state in OS?",
      "options": ["Memory location", "Condition of process at a moment", "Priority level", "File handle"],
      "correct_answer": "Condition of process at a moment",
      "hint": "New, Ready, Running, Waiting, Terminated",
      "explanation": "A process state represents the current condition: New (created), Ready (waiting to run), Running (executing), Waiting (blocked for I/O), or Terminated (finished).",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["process state", "lifecycle", "OS", "scheduling"]
    },
    {
      "id": 20,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the purpose of a wait-for graph in OS?",
      "options": ["Process scheduling", "Memory allocation", "Deadlock detection", "File management"],
      "correct_answer": "Deadlock detection",
      "hint": "Shows resource and process relationships",
      "explanation": "A wait-for graph shows which processes are waiting for resources held by others. A cycle in the graph indicates deadlock situation.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["wait-for graph", "deadlock", "detection", "resource"]
    },
    {
      "id": 21,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is virtual memory?",
      "options": ["Memory that doesn't exist", "Extension of RAM using disk", "Cache memory", "ROM"],
      "correct_answer": "Extension of RAM using disk",
      "hint": "Uses disk to simulate more RAM",
      "explanation": "Virtual memory extends available memory by using disk storage. The OS swaps data between RAM and disk, allowing programs larger than physical RAM to run.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["virtual memory", "paging", "disk", "memory management"]
    },
    {
      "id": 22,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What are the main page replacement algorithms?",
      "options": ["LRU, FIFO, LFU", "Read and Write", "Cache policies", "Memory mapping"],
      "correct_answer": "LRU, FIFO, LFU",
      "hint": "Determine which page to evict",
      "explanation": "Main algorithms: LRU (Least Recently Used), FIFO (First-In-First-Out), LFU (Least Frequently Used). They determine which page to remove when memory is full.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Hard",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["LRU", "FIFO", "LFU", "page replacement", "algorithm"]
    },
    {
      "id": 23,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is context switching?",
      "options": ["Changing context of execution", "Saving current process state and loading another", "Data transfer", "Memory swap"],
      "correct_answer": "Saving current process state and loading another",
      "hint": "Enables multitasking on single processor",
      "explanation": "Context switching is the OS operation of saving the current process's state and loading another process to execute. It enables multitasking by time-sharing the CPU.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "7.5 - Operating System Basics",
      "keywords": ["context switch", "process state", "CPU scheduling", "OS"]
    },
    {
      "id": 24,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What are the main CPU scheduling algorithms?",
      "options": ["FCFS, SJF, Round Robin, Priority", "Only FCFS", "First-Come-First-Served only", "Random selection"],
      "correct_answer": "FCFS, SJF, Round Robin, Priority",
      "hint": "Different strategies for allocating CPU time",
      "explanation": "Main algorithms: FCFS (First-Come-First-Served), SJF (Shortest Job First), Round Robin (time slices), Priority-based. Each has different performance characteristics.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Hard",
      "related_section": "7.5 - Operating System Basics",
      "keywords": ["CPU scheduling", "FCFS", "SJF", "Round Robin", "Priority"]
    },
    {
      "id": 25,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a semaphore in OS?",
      "options": ["Signal flag", "Synchronization primitive for mutual exclusion", "Process identifier", "Memory segment"],
      "correct_answer": "Synchronization primitive for mutual exclusion",
      "hint": "Manages access to shared resources",
      "explanation": "A semaphore is a synchronization mechanism that controls access to shared resources. It's a counter with P (wait) and V (signal) operations for mutual exclusion.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["semaphore", "synchronization", "mutex", "critical section"]
    },
    {
      "id": 26,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a graph data structure?",
      "options": ["Visual representation", "Collection of vertices connected by edges", "Tree structure", "Array structure"],
      "correct_answer": "Collection of vertices connected by edges",
      "hint": "Non-linear data structure",
      "explanation": "A graph is a non-linear data structure consisting of vertices (nodes) and edges (connections). It can be directed or undirected, weighted or unweighted.",
      "source": "Model Set",
      "difficulty": "Easy",
      "related_section": "7.2 - Trees and Graphs",
      "keywords": ["graph", "vertex", "edge", "data structure"]
    },
    {
      "id": 27,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a tree data structure?",
      "options": ["Linear collection", "Hierarchical structure with root and child nodes", "Random access", "Unordered collection"],
      "correct_answer": "Hierarchical structure with root and child nodes",
      "hint": "No cycles, connected graph",
      "explanation": "A tree is a hierarchical data structure with a root node and child nodes. It's a special graph with no cycles and exactly one path between any two nodes.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Easy",
      "related_section": "7.2 - Trees and Graphs",
      "keywords": ["tree", "root", "leaf", "hierarchy", "data structure"]
    },
    {
      "id": 28,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the purpose of a hash table?",
      "options": ["Store hashed values", "Fast key-value lookup using hash function", "Encryption", "Data compression"],
      "correct_answer": "Fast key-value lookup using hash function",
      "hint": "Maps keys to values efficiently",
      "explanation": "A hash table uses a hash function to map keys to array indices, enabling O(1) average case lookup. Collisions are handled by chaining or open addressing.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "7.2 - Trees and Graphs",
      "keywords": ["hash table", "hash function", "lookup", "collision"]
    },
    {
      "id": 29,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a trie data structure?",
      "options": ["Binary tree", "Tree for storing strings/sequences", "Hash table", "Array structure"],
      "correct_answer": "Tree for storing strings/sequences",
      "hint": "Efficient for prefix searching",
      "explanation": "A trie (prefix tree) is a tree structure where each node represents a character. It's efficient for string searches, autocomplete, and spell checking.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "7.2 - Trees and Graphs",
      "keywords": ["trie", "prefix tree", "string search", "data structure"]
    },
    {
      "id": 30,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the E-R (Entity-Relationship) model?",
      "options": ["Error Recovery", "Entity-Relationship model for database design", "Electronic Record", "Exchange Rate"],
      "correct_answer": "Entity-Relationship model for database design",
      "hint": "Shows entities and their relationships",
      "explanation": "The E-R model is a conceptual model for database design. It represents entities (objects), attributes (properties), and relationships between entities graphically.",
      "source": "Model Set",
      "difficulty": "Medium",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["E-R model", "entity", "relationship", "database design"]
    },
    {
      "id": 31,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What are the tree traversal methods?",
      "options": ["Inorder, Preorder, Postorder", "Only Inorder", "Forward and Backward", "Up and Down"],
      "correct_answer": "Inorder, Preorder, Postorder",
      "hint": "Different orders to visit tree nodes",
      "explanation": "Three main DFS traversal methods: Inorder (left-root-right), Preorder (root-left-right), Postorder (left-right-root). BFS (level-order) is another method.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "7.2 - Trees and Graphs",
      "keywords": ["tree traversal", "DFS", "BFS", "inorder", "preorder", "postorder"]
    },
    {
      "id": 32,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is quick sort algorithm?",
      "options": ["Always fastest sorting", "Divide-and-conquer with pivot partitioning", "Insertion-based", "Bubble sort variant"],
      "correct_answer": "Divide-and-conquer with pivot partitioning",
      "hint": "Picks pivot and partitions array",
      "explanation": "Quick sort uses divide-and-conquer: select pivot, partition array, recursively sort. O(n log n) average, O(n^2) worst case. Generally faster than merge sort in practice.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "7.3 - Sorting and Searching",
      "keywords": ["quick sort", "pivot", "partition", "divide-and-conquer"]
    },
    {
      "id": 33,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a B-tree?",
      "options": ["Binary tree", "Balanced search tree used in databases", "Boolean tree", "Basic tree"],
      "correct_answer": "Balanced search tree used in databases",
      "hint": "Maintains sorted order and balance",
      "explanation": "A B-tree is a self-balancing search tree optimized for disk I/O. It's widely used in databases and file systems for efficient data retrieval.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "7.2 - Trees and Graphs",
      "keywords": ["B-tree", "balanced", "search tree", "database"]
    },
    {
      "id": 34,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is an AVL tree?",
      "options": ["Any tree", "Self-balancing BST with height difference ≤1", "Average tree", "Automatic tree"],
      "correct_answer": "Self-balancing BST with height difference ≤1",
      "hint": "Maintains balance factor for height",
      "explanation": "An AVL tree is a self-balancing binary search tree where height difference between left and right subtrees is at most 1. It ensures O(log n) operations.",
      "source": "Model Set",
      "difficulty": "Hard",
      "related_section": "7.2 - Trees and Graphs",
      "keywords": ["AVL tree", "balanced", "height", "rotation", "BST"]
    },
    {
      "id": 35,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is deadlock in OS?",
      "options": ["System crash", "Situation where processes wait for resources held by others", "Memory leak", "Process error"],
      "correct_answer": "Situation where processes wait for resources held by others",
      "hint": "Circular wait for resources",
      "explanation": "Deadlock occurs when multiple processes are stuck waiting for resources held by each other, forming a circular dependency. Prevents progress indefinitely.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["deadlock", "circular wait", "resources", "process", "OS"]
    },
    {
      "id": 36,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What are the necessary conditions for deadlock?",
      "options": ["Mutual exclusion, hold and wait, no preemption, circular wait", "Only one condition", "Mutual exclusion only", "Any resource conflict"],
      "correct_answer": "Mutual exclusion, hold and wait, no preemption, circular wait",
      "hint": "All four conditions must be present",
      "explanation": "Deadlock requires all four: Mutual Exclusion (exclusive resource access), Hold and Wait (holding while waiting), No Preemption (cannot force resource release), Circular Wait (cyclic dependency).",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Hard",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["deadlock", "necessary conditions", "mutual exclusion", "circular wait"]
    },
    {
      "id": 37,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is merge sort?",
      "options": ["Joining two arrays", "Divide-and-conquer sorting O(n log n)", "Insertion into array", "Bubble sort variant"],
      "correct_answer": "Divide-and-conquer sorting O(n log n)",
      "hint": "Divides and merges sorted subarrays",
      "explanation": "Merge sort divides array into halves, recursively sorts each half, and merges them. O(n log n) in all cases. Requires O(n) extra space.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "7.3 - Sorting and Searching",
      "keywords": ["merge sort", "divide-and-conquer", "O(n log n)", "stable sort"]
    },
    {
      "id": 38,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is heap sort?",
      "options": ["Sorting using heap data structure", "Memory sorting", "Fast sorting only", "Random sorting"],
      "correct_answer": "Sorting using heap data structure",
      "hint": "Builds max/min heap and extracts",
      "explanation": "Heap sort builds a heap from array elements, then repeatedly extracts the maximum. O(n log n) time, O(1) space. Not stable but in-place.",
      "source": "Model Set",
      "difficulty": "Medium",
      "related_section": "7.3 - Sorting and Searching",
      "keywords": ["heap sort", "heap", "O(n log n)", "in-place"]
    },
    {
      "id": 39,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is index in database?",
      "options": ["Column number", "Data structure for fast lookup of values", "Table row number", "Query result"],
      "correct_answer": "Data structure for fast lookup of values",
      "hint": "Speeds up query performance",
      "explanation": "A database index is a data structure (like B-tree) that speeds up data retrieval. It maps column values to row locations, enabling faster lookups than full table scans.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Easy",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["index", "database", "lookup", "performance"]
    },
    {
      "id": 40,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the difference between inner and outer join?",
      "options": ["Inner returns matching rows, outer includes non-matching", "Inner is faster", "Outer is always used", "No difference"],
      "correct_answer": "Inner returns matching rows, outer includes non-matching",
      "hint": "Inner join - only matches, outer - includes nulls",
      "explanation": "Inner join returns only rows with matches in both tables. Outer join (left, right, full) includes non-matching rows as well, with NULL values for missing data.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["join", "inner", "outer", "SQL", "relational"]
    },
    {
      "id": 41,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is memory segmentation?",
      "options": ["Dividing memory into fixed partitions", "Dividing memory into variable-sized logical segments", "Disk organization", "Cache arrangement"],
      "correct_answer": "Dividing memory into variable-sized logical segments",
      "hint": "Creates logical address space",
      "explanation": "Memory segmentation divides memory into variable-sized logical segments (code, data, stack, etc.). Each segment can grow/shrink independently and has separate protection.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["segmentation", "memory management", "logical address", "segment"]
    },
    {
      "id": 42,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is memory paging?",
      "options": ["Page arrangement", "Dividing memory into fixed-size pages for virtual memory", "Caching", "Storage method"],
      "correct_answer": "Dividing memory into fixed-size pages for virtual memory",
      "hint": "Enables virtual memory management",
      "explanation": "Paging divides physical memory and logical address space into fixed-size pages. It enables virtual memory by swapping pages between RAM and disk.",
      "source": "Model Set",
      "difficulty": "Medium",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["paging", "page", "virtual memory", "memory management"]
    },
    {
      "id": 43,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is DFS in graph algorithms?",
      "options": ["Distance-First Search", "Depth-First Search - explores deeply before backtracking", "Data Flow Search", "Direct File Search"],
      "correct_answer": "Depth-First Search - explores deeply before backtracking",
      "hint": "Uses stack for exploration",
      "explanation": "DFS explores a graph by going deep into branches before backtracking. It uses a stack and is useful for cycle detection, topological sorting, and connected components.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "7.2 - Trees and Graphs",
      "keywords": ["DFS", "depth-first", "graph", "stack", "algorithm"]
    },
    {
      "id": 44,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is BFS in graph algorithms?",
      "options": ["Breadth-First Search - explores level-by-level", "Binary-First Search", "Basic-First Search", "Batch-First Search"],
      "correct_answer": "Breadth-First Search - explores level-by-level",
      "hint": "Uses queue for exploration",
      "explanation": "BFS explores graph level-by-level using a queue. It finds shortest paths in unweighted graphs and is useful for level-order traversal and connectivity analysis.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "7.2 - Trees and Graphs",
      "keywords": ["BFS", "breadth-first", "graph", "queue", "shortest path"]
    },
    {
      "id": 45,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a cursor in database?",
      "options": ["Mouse pointer", "Database pointer for row-by-row processing", "SQL command", "Index structure"],
      "correct_answer": "Database pointer for row-by-row processing",
      "hint": "Allows sequential access to query results",
      "explanation": "A cursor is a database object that allows row-by-row processing of query results. It maintains position and can fetch one row at a time.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["cursor", "database", "row processing", "SQL"]
    },
    {
      "id": 46,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a view in database?",
      "options": ["Display option", "Virtual table created from query result", "Index", "Database file"],
      "correct_answer": "Virtual table created from query result",
      "hint": "Based on one or more tables",
      "explanation": "A view is a virtual table based on SELECT query result. It doesn't store data, but provides simplified/customized view of underlying tables. Useful for security and abstraction.",
      "source": "Model Set",
      "difficulty": "Medium",
      "related_section": "7.4 - Database Fundamentals and SQL",
      "keywords": ["view", "virtual table", "database", "query"]
    },
    {
      "id": 47,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is IPC in OS?",
      "options": ["Internet Protocol Communication", "Inter-Process Communication between processes", "Input-Process-Compute", "Instruction Pipeline Control"],
      "correct_answer": "Inter-Process Communication between processes",
      "hint": "Allows processes to exchange data",
      "explanation": "IPC (Inter-Process Communication) enables processes to exchange data and synchronize. Methods include pipes, sockets, shared memory, and message queues.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "7.5 - Operating System Basics",
      "keywords": ["IPC", "inter-process", "communication", "synchronization"]
    },
    {
      "id": 48,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is swapping in OS memory management?",
      "options": ["Exchanging data", "Moving entire process between RAM and disk", "Memory reallocation", "Cache update"],
      "correct_answer": "Moving entire process between RAM and disk",
      "hint": "Frees memory by removing processes temporarily",
      "explanation": "Swapping moves entire process from RAM to disk and vice versa. It frees RAM for other processes but is slower than paging individual pages.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Hard",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["swapping", "process", "disk", "memory management"]
    },
    {
      "id": 49,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is TLB in memory management?",
      "options": ["Table Lookup Buffer", "Translation Lookaside Buffer - caches address translations", "Table Load Batch", "Transfer Link Buffer"],
      "correct_answer": "Translation Lookaside Buffer - caches address translations",
      "hint": "Speeds up virtual address translation",
      "explanation": "TLB is a cache that stores recent virtual-to-physical address translations. It speeds up the address translation process in virtual memory systems.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "7.6 - Process and Memory Management",
      "keywords": ["TLB", "translation", "address", "cache", "memory"]
    },
    {
      "id": 50,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the difference between preemptive and non-preemptive scheduling?",
      "options": ["Preemptive allows interruption, non-preemptive doesn't", "No difference", "Non-preemptive is faster", "Preemptive uses more memory"],
      "correct_answer": "Preemptive allows interruption, non-preemptive doesn't",
      "hint": "Whether process can be forced to give up CPU",
      "explanation": "Preemptive scheduling can interrupt a running process and allocate CPU to another. Non-preemptive scheduling lets process run until completion. Preemptive is more responsive.",
      "source": "Model Set",
      "difficulty": "Medium",
      "related_section": "7.5 - Operating System Basics",
      "keywords": ["preemptive", "non-preemptive", "scheduling", "CPU allocation"]
    }
  ]
}
