{
  "chapter": "3. Programming Language and Its Applications",
  "chapter_code": "ACtE03",
  "total_questions": 40,
  "summary": "This chapter covers C and C++ programming languages, including fundamentals, pointers, structures, object-oriented programming, and advanced concepts like templates and exception handling.",
  "subsections": [
    {
      "section": "3.1 - C Programming Fundamentals",
      "topic_code": "ACtE0301",
      "question_count": 7
    },
    {
      "section": "3.2 - Pointers and Structures",
      "topic_code": "ACtE0302",
      "question_count": 8
    },
    {
      "section": "3.3 - C++ Basics and Classes",
      "topic_code": "ACtE0303",
      "question_count": 8
    },
    {
      "section": "3.4 - Operator and Function Overloading",
      "topic_code": "ACtE0304",
      "question_count": 7
    },
    {
      "section": "3.5 - Inheritance and Polymorphism",
      "topic_code": "ACtE0305",
      "question_count": 7
    },
    {
      "section": "3.6 - Templates and Exception Handling",
      "topic_code": "ACtE0306",
      "question_count": 3
    }
  ],
  "questions": [
    {
      "id": 1,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "Given the following code: int *p, u; float *y,x; Which of the following is the correct next line of code?",
      "options": [
        "p = &u",
        "p = u",
        "y = &x",
        "y = x"
      ],
      "correct_answer": "p = &u",
      "hint": "Pointer types must match the variable type they point to",
      "explanation": "The correct answer is 'p = &u'. Since p is declared as a pointer to int and u is an int, the assignment p = &u is correct. The ampersand (&) is the address-of operator that gives the memory address of u. The other options are incorrect because 'p = u' tries to assign an integer value to a pointer.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Medium",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["pointer", "address-of operator", "type matching"]
    },
    {
      "id": 2,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "In C++, what is the output of the following code? class A { public: virtual void display() { cout << \"A\"; } }; class B : public A { public: void display() override { cout << \"B\"; } }; int main() { A *ptr = new B(); ptr->display(); delete ptr; return 0; }",
      "options": [
        "A",
        "B",
        "AB",
        "Error"
      ],
      "correct_answer": "B",
      "hint": "Virtual functions enable polymorphism - runtime type matters",
      "explanation": "The output is 'B'. Although ptr is a pointer to class A, it actually points to an object of class B. When ptr->display() is called, virtual function mechanism ensures that B's display() method is invoked (not A's), so 'B' is printed. This demonstrates dynamic dispatch or late binding in C++.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Hard",
      "related_section": "3.5 - Inheritance and Polymorphism",
      "keywords": ["virtual function", "polymorphism", "inheritance", "override"]
    },
    {
      "id": 3,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What does the C function call fwrite(str, strlen(str) + 1, 1, filePointer) do?",
      "options": [
        "Prints all string characters including the null character",
        "Prints all string characters except the null character",
        "Writes the length of the string to the file",
        "Writes the string length plus one to the file"
      ],
      "correct_answer": "Prints all string characters including the null character",
      "hint": "strlen(str) + 1 includes the null terminator",
      "explanation": "The fwrite() function writes all string characters including the null character to a file. The parameters are: str (data), strlen(str) + 1 (number of bytes including null), 1 (number of items), and filePointer. By using strlen(str) + 1, the null terminator ('\\0') is also written.",
      "source": "Set 2 (Aasadh, 2081) - Short Questions",
      "difficulty": "Medium",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["fwrite", "file handling", "string", "null character"]
    },
    {
      "id": 4,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is single-level inheritance?",
      "options": [
        "A class inherited from multiple base classes",
        "A class inherited from a single base class",
        "A base class inherited from multiple derived classes",
        "A class that cannot be inherited"
      ],
      "correct_answer": "A class inherited from a single base class",
      "hint": "Single-level means one inheritance step",
      "explanation": "Single-level inheritance is when a class is inherited from a single base class. There is only one level of inheritance: one derived class directly inherits from one base class. This is the simplest form of inheritance in object-oriented programming.",
      "source": "Set 2 (Aasadh, 2081) - Long Questions",
      "difficulty": "Easy",
      "related_section": "3.5 - Inheritance and Polymorphism",
      "keywords": ["single-level inheritance", "derived class", "base class"]
    },
    {
      "id": 5,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is the default access specifier for data members in a C++ class?",
      "options": [
        "Public",
        "Protected",
        "Private",
        "None"
      ],
      "correct_answer": "Private",
      "hint": "Class members are restricted by default",
      "explanation": "The default access specifier for data members in a C++ class is private. This means class members are not accessible from outside the class unless explicitly declared as public or protected. This default enforces encapsulation and data hiding.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Easy",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["access specifier", "private", "public", "protected", "encapsulation"]
    },
    {
      "id": 6,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What concept in object-oriented programming allows objects of different classes to be treated as objects of a common base class?",
      "options": [
        "Encapsulation",
        "Inheritance",
        "Polymorphism",
        "Abstraction"
      ],
      "correct_answer": "Polymorphism",
      "hint": "This allows flexible object usage across different types",
      "explanation": "Polymorphism is the concept that allows objects of different classes to be treated as objects of a common base class. Polymorphism enables writing flexible code where functions can work with objects of different derived classes through a common base class interface. This is achieved through method overriding (runtime polymorphism) and method overloading (compile-time polymorphism).",
      "source": "Set 3 (Asojh, 2080) - Long Questions",
      "difficulty": "Medium",
      "related_section": "3.5 - Inheritance and Polymorphism",
      "keywords": ["polymorphism", "base class", "derived class", "inheritance"]
    },
    {
      "id": 7,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "Which C function is used to find the current position in a file?",
      "options": [
        "fseek()",
        "ftell()",
        "fgetpos()",
        "rewind()"
      ],
      "correct_answer": "ftell()",
      "hint": "The name suggests 'file tell position'",
      "explanation": "The ftell() function is used to find the current position in a file. ftell() returns the current file position as a long integer. This function is useful for determining where you are in a file during reading or writing operations. Returns -1L if an error occurs.",
      "source": "Set 1 (Chaitra, 2080) - Short Questions",
      "difficulty": "Easy",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["file handling", "ftell", "file position"]
    },
    {
      "id": 8,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What type of learning algorithm is Naive Bayes?",
      "options": [
        "Unsupervised",
        "Supervised",
        "Reinforcement",
        "Semi-supervised"
      ],
      "correct_answer": "Supervised",
      "hint": "Naive Bayes requires labeled training data",
      "explanation": "Naive Bayes is a supervised learning algorithm. Supervised learning algorithms require labeled training data to learn the relationship between input features and output labels. Naive Bayes is a probabilistic classifier that uses Bayes' theorem with the assumption of feature independence.",
      "source": "Set 1 (Chaitra, 2080) - Long Questions",
      "difficulty": "Medium",
      "related_section": "3.6 - Templates and Exception Handling",
      "keywords": ["Naive Bayes", "supervised learning", "probabilistic classifier"]
    },
    {
      "id": 9,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "In C, what is a structure?",
      "options": [
        "A collection of functions",
        "A collection of variables of different types grouped under one name",
        "A type of loop",
        "A preprocessor directive"
      ],
      "correct_answer": "A collection of variables of different types grouped under one name",
      "hint": "Structures allow grouping related data",
      "explanation": "In C, a structure is a collection of variables of different types grouped under one name. Structures allow you to create composite data types that combine multiple data members. Each member can have a different data type, unlike arrays which must contain elements of the same type.",
      "source": "Set 2 (Aasadh, 2081) - Short Questions",
      "difficulty": "Easy",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["structure", "struct", "data type", "members"]
    },
    {
      "id": 10,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is function overloading?",
      "options": [
        "Defining multiple functions with the same name but different parameters",
        "Calling a function multiple times",
        "Assigning a function to a pointer",
        "Modifying a function's code at runtime"
      ],
      "correct_answer": "Defining multiple functions with the same name but different parameters",
      "hint": "Same function name, different signatures",
      "explanation": "Function overloading is defining multiple functions with the same name but different parameters (different types, number, or order of parameters). The compiler determines which function to call based on the arguments passed. This is a form of compile-time (static) polymorphism in C++.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "3.4 - Operator and Function Overloading",
      "keywords": ["overloading", "function", "parameters", "polymorphism"]
    },
    {
      "id": 11,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a pointer in C?",
      "options": [
        "A variable that stores the address of another variable",
        "A variable that stores the value of another variable",
        "A function that points to another function",
        "A type of loop"
      ],
      "correct_answer": "A variable that stores the address of another variable",
      "hint": "Pointers hold memory addresses",
      "explanation": "A pointer in C is a variable that stores the memory address of another variable. You declare a pointer using the asterisk (*) symbol, and you get the address of a variable using the ampersand (&) operator. Pointers are fundamental to C programming for dynamic memory allocation and complex data structures.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Easy",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["pointer", "address", "memory", "dereference"]
    },
    {
      "id": 12,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the difference between a class and a structure in C++?",
      "options": [
        "Classes are used for functions, structures for data",
        "The default access specifier is private for classes and public for structures",
        "Classes support inheritance, structures do not",
        "There is no difference"
      ],
      "correct_answer": "The default access specifier is private for classes and public for structures",
      "hint": "Access control is the main difference",
      "explanation": "In C++, the main difference between a class and a structure is the default access specifier. Classes have private access by default, while structures have public access by default. Both can have member functions, constructors, inheritance, and all other OOP features.",
      "source": "Set 2 (Aasadh, 2081) - Long Questions",
      "difficulty": "Medium",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["class", "structure", "access specifier", "private", "public"]
    },
    {
      "id": 13,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is operator overloading?",
      "options": [
        "Using the same operator multiple times in an expression",
        "Defining custom behavior for built-in operators for user-defined types",
        "Creating new operators",
        "Removing operators from a program"
      ],
      "correct_answer": "Defining custom behavior for built-in operators for user-defined types",
      "hint": "Operators like +, -, * can be customized for classes",
      "explanation": "Operator overloading is defining custom behavior for built-in operators when used with user-defined types (classes). For example, you can overload the + operator to add two objects of your custom class. This allows operators to work intuitively with your own data types.",
      "source": "Set 1 (Chaitra, 2080) - Short Questions",
      "difficulty": "Medium",
      "related_section": "3.4 - Operator and Function Overloading",
      "keywords": ["operator overloading", "custom behavior", "user-defined types"]
    },
    {
      "id": 14,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a template in C++?",
      "options": [
        "A blueprint for creating generic classes or functions",
        "A type of loop",
        "A preprocessor directive",
        "A memory allocation technique"
      ],
      "correct_answer": "A blueprint for creating generic classes or functions",
      "hint": "Templates allow writing code that works with multiple types",
      "explanation": "A template in C++ is a blueprint for creating generic classes or functions that work with multiple data types. Templates are instantiated at compile-time for each type used. They provide a way to write reusable, type-safe code without duplication.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "3.6 - Templates and Exception Handling",
      "keywords": ["template", "generic", "instantiation", "type"]
    },
    {
      "id": 15,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is the purpose of try-catch blocks in C++?",
      "options": [
        "To loop through arrays",
        "To handle exceptions and errors",
        "To declare variables",
        "To define functions"
      ],
      "correct_answer": "To handle exceptions and errors",
      "hint": "Try-catch is exception handling mechanism",
      "explanation": "Try-catch blocks in C++ are used to handle exceptions and errors. The try block contains code that might throw an exception, and the catch block handles the exception if it occurs. This allows programs to gracefully handle errors without crashing.",
      "source": "Set 2 (Aasadh, 2081) - Short Questions",
      "difficulty": "Easy",
      "related_section": "3.6 - Templates and Exception Handling",
      "keywords": ["exception", "try-catch", "error handling", "throw"]
    },
    {
      "id": 16,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is multiple inheritance?",
      "options": [
        "A derived class inheriting from multiple base classes",
        "A base class inherited by multiple derived classes",
        "Inheriting from the same class multiple times",
        "Using inheritance multiple times in a program"
      ],
      "correct_answer": "A derived class inheriting from multiple base classes",
      "hint": "One derived class, multiple parent classes",
      "explanation": "Multiple inheritance is when a derived class inherits from multiple base classes. A single derived class can inherit properties and methods from two or more base classes. This provides more flexibility but can introduce complexity such as the diamond problem.",
      "source": "Set 1 (Chaitra, 2080) - Long Questions",
      "difficulty": "Hard",
      "related_section": "3.5 - Inheritance and Polymorphism",
      "keywords": ["multiple inheritance", "derived class", "base class", "diamond problem"]
    },
    {
      "id": 17,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a virtual function?",
      "options": [
        "A function that doesn't have a body",
        "A function that can be overridden in derived classes",
        "A function that doesn't return a value",
        "A function that is called at compile time"
      ],
      "correct_answer": "A function that can be overridden in derived classes",
      "hint": "Virtual functions enable runtime polymorphism",
      "explanation": "A virtual function is a member function that can be overridden in derived classes. Virtual functions enable runtime (dynamic) polymorphism. When a virtual function is called through a pointer or reference to a base class, the actual function called is determined by the runtime type of the object.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Medium",
      "related_section": "3.5 - Inheritance and Polymorphism",
      "keywords": ["virtual function", "override", "polymorphism", "derived class"]
    },
    {
      "id": 18,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is dynamic memory allocation in C?",
      "options": [
        "Allocating memory at compile time",
        "Allocating memory at runtime using pointers",
        "Allocating memory to functions",
        "Allocating memory to arrays"
      ],
      "correct_answer": "Allocating memory at runtime using pointers",
      "hint": "Uses malloc, calloc, realloc functions",
      "explanation": "Dynamic memory allocation in C is the process of allocating memory at runtime using pointers. Functions like malloc(), calloc(), and realloc() are used for dynamic allocation, and free() is used to deallocate memory. This allows programs to request memory based on runtime requirements.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["dynamic allocation", "malloc", "free", "memory management"]
    },
    {
      "id": 19,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is the keyword 'new' used for in C++?",
      "options": [
        "To declare a new variable",
        "To allocate memory on the heap",
        "To create a new function",
        "To initialize an array"
      ],
      "correct_answer": "To allocate memory on the heap",
      "hint": "Newer than malloc()",
      "explanation": "The 'new' keyword in C++ is used to allocate memory on the heap at runtime. It returns a pointer to the allocated memory. 'new' is the C++ alternative to C's malloc() function and also calls constructors for objects.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Easy",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["new", "delete", "heap", "memory allocation"]
    },
    {
      "id": 20,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is const correctness in C++?",
      "options": [
        "Using const keyword to indicate that values cannot be modified",
        "Ensuring all functions are constant",
        "Making all variables immutable",
        "Preventing function overloading"
      ],
      "correct_answer": "Using const keyword to indicate that values cannot be modified",
      "hint": "Const prevents unintended modifications",
      "explanation": "Const correctness in C++ is using the const keyword to indicate that values, pointers, or member functions cannot be modified. This helps prevent unintended modifications and makes code intentions clear. Const can be applied to variables, pointers, references, and member functions.",
      "source": "Set 2 (Aasadh, 2081) - Long Questions",
      "difficulty": "Medium",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["const", "const correctness", "immutable", "const member function"]
    },
    {
      "id": 21,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a constructor in C++?",
      "options": [
        "A function that destroys objects",
        "A special function called when an object is created",
        "A function that copies objects",
        "A function that returns a value"
      ],
      "correct_answer": "A special function called when an object is created",
      "hint": "Constructors initialize objects",
      "explanation": "A constructor in C++ is a special member function that is called automatically when an object is created. Constructors are used to initialize object data members. They have the same name as the class and no return type.",
      "source": "Set 1 (Chaitra, 2080) - Short Questions",
      "difficulty": "Easy",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["constructor", "initialization", "member function"]
    },
    {
      "id": 22,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a destructor in C++?",
      "options": [
        "A function that creates objects",
        "A special function called when an object is destroyed",
        "A function that modifies objects",
        "A function that copies objects"
      ],
      "correct_answer": "A special function called when an object is destroyed",
      "hint": "Destructors clean up resources",
      "explanation": "A destructor in C++ is a special member function that is called automatically when an object is destroyed. Destructors are used to release resources acquired by the object (like dynamically allocated memory). They have the same name as the class preceded by a tilde (~) and no return type.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["destructor", "cleanup", "resource deallocation"]
    },
    {
      "id": 23,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is encapsulation?",
      "options": [
        "Wrapping data and methods in a class",
        "Inheriting from multiple classes",
        "Overloading operators",
        "Allocating memory dynamically"
      ],
      "correct_answer": "Wrapping data and methods in a class",
      "hint": "Data hiding and access control",
      "explanation": "Encapsulation is the wrapping of data (attributes) and methods (functions) in a class, and hiding the internal details from the outside world. Through encapsulation, we can control access to data using access specifiers (private, public, protected), which helps maintain data integrity and security.",
      "source": "Set 2 (Aasadh, 2081) - Short Questions",
      "difficulty": "Easy",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["encapsulation", "data hiding", "access control"]
    },
    {
      "id": 24,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the this pointer in C++?",
      "options": [
        "A pointer to the current object",
        "A pointer to the base class",
        "A pointer to the derived class",
        "A pointer to the global object"
      ],
      "correct_answer": "A pointer to the current object",
      "hint": "Points to the object on which a member function is called",
      "explanation": "The 'this' pointer in C++ is an implicit pointer to the current object (the object on which a member function is called). It allows member functions to access and manipulate the data members of the specific object instance.",
      "source": "Set 1 (Chaitra, 2080) - Long Questions",
      "difficulty": "Medium",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["this pointer", "current object", "member function"]
    },
    {
      "id": 25,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is the purpose of the static keyword in C++?",
      "options": [
        "To create global variables",
        "To define class-level or function-level variables with static storage duration",
        "To prevent inheritance",
        "To allow external linking"
      ],
      "correct_answer": "To define class-level or function-level variables with static storage duration",
      "hint": "Static members are shared by all objects of a class",
      "explanation": "The static keyword in C++ is used to define class-level or function-level variables with static storage duration. Static member variables are shared by all objects of the class (not instance-specific). Static functions can only access static members.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Medium",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["static", "class variable", "storage duration"]
    },
    {
      "id": 26,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a reference in C++?",
      "options": [
        "An alias for another variable",
        "A pointer to another variable",
        "A copy of another variable",
        "A function that returns a variable"
      ],
      "correct_answer": "An alias for another variable",
      "hint": "References cannot be reassigned",
      "explanation": "A reference in C++ is an alias for another variable. Once a reference is initialized to refer to a variable, it always refers to that variable. References are similar to pointers but with important differences: they cannot be null, cannot be reassigned, and are automatically dereferenced.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["reference", "alias", "pointer", "dereference"]
    },
    {
      "id": 27,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is an inline function?",
      "options": [
        "A function defined inside a class",
        "A function whose code is inserted at the point of call",
        "A function that is called in a loop",
        "A function that returns an inline variable"
      ],
      "correct_answer": "A function whose code is inserted at the point of call",
      "hint": "Inline functions reduce function call overhead",
      "explanation": "An inline function is a function whose code is expanded at the point of call, rather than being called as a separate function. The 'inline' keyword suggests to the compiler that it should replace function calls with the actual function code. This can improve performance for small functions by eliminating call overhead.",
      "source": "Set 1 (Chaitra, 2080) - Short Questions",
      "difficulty": "Medium",
      "related_section": "3.1 - C Programming Fundamentals",
      "keywords": ["inline function", "expansion", "performance"]
    },
    {
      "id": 28,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is namespace in C++?",
      "options": [
        "A way to group classes and functions",
        "A type of variable",
        "A memory location",
        "A keyword for accessing private members"
      ],
      "correct_answer": "A way to group classes and functions",
      "hint": "Prevents naming conflicts",
      "explanation": "A namespace in C++ is a way to group classes, functions, and variables under a single name. Namespaces help prevent naming conflicts and organize code logically. The std namespace contains the C++ Standard Library.",
      "source": "Set 2 (Aasadh, 2081) - Long Questions",
      "difficulty": "Easy",
      "related_section": "3.1 - C Programming Fundamentals",
      "keywords": ["namespace", "std", "scope", "organization"]
    },
    {
      "id": 29,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is the purpose of the extern keyword in C?",
      "options": [
        "To declare an external variable",
        "To declare a local variable",
        "To declare a static variable",
        "To declare a constant"
      ],
      "correct_answer": "To declare an external variable",
      "hint": "Allows access to variables defined in other files",
      "explanation": "The extern keyword in C is used to declare an external variable - a variable that is defined in another file. It tells the compiler that the variable exists elsewhere and should be linked when the program is compiled.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Easy",
      "related_section": "3.1 - C Programming Fundamentals",
      "keywords": ["extern", "external variable", "linking"]
    },
    {
      "id": 30,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the difference between malloc and calloc?",
      "options": [
        "malloc allocates memory while calloc initializes it to zero",
        "calloc is faster than malloc",
        "malloc is for C++ and calloc is for C",
        "There is no difference"
      ],
      "correct_answer": "malloc allocates memory while calloc initializes it to zero",
      "hint": "calloc = contiguous allocation",
      "explanation": "malloc() allocates memory but does not initialize it (contains garbage values), while calloc() allocates memory AND initializes all bits to zero. calloc() also takes two parameters (number of elements and size of each element), while malloc() takes one (total bytes).",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["malloc", "calloc", "memory allocation", "initialization"]
    },
    {
      "id": 31,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a lambda function in C++?",
      "options": [
        "An anonymous function defined inline",
        "A function that returns another function",
        "A function without a name",
        "A mathematical function"
      ],
      "correct_answer": "An anonymous function defined inline",
      "hint": "Lambda functions are written as [](){} syntax",
      "explanation": "A lambda function in C++ is an anonymous function that is defined inline. Lambda functions allow you to define small functions without formally declaring them. They are useful for short operations, especially when used with algorithms like std::sort() or std::for_each().",
      "source": "Set 2 (Aasadh, 2081) - Short Questions",
      "difficulty": "Medium",
      "related_section": "3.6 - Templates and Exception Handling",
      "keywords": ["lambda function", "anonymous function", "closure"]
    },
    {
      "id": 32,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the purpose of the -> operator in C++?",
      "options": [
        "To access members of an object through a pointer",
        "To access members of an object directly",
        "To declare a pointer",
        "To compare two values"
      ],
      "correct_answer": "To access members of an object through a pointer",
      "hint": "Combines dereferencing and member access",
      "explanation": "The -> operator (arrow operator) in C++ is used to access members of a class or struct through a pointer. It combines dereferencing (*) and member access (.) in one operator. ptr->member is equivalent to (*ptr).member.",
      "source": "Set 1 (Chaitra, 2080) - Long Questions",
      "difficulty": "Easy",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["arrow operator", "pointer", "member access"]
    },
    {
      "id": 33,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is the scope resolution operator in C++?",
      "options": [
        "The dot (.)",
        "The double colon (::)",
        "The arrow (->)",
        "The asterisk (*)"
      ],
      "correct_answer": "The double colon (::)",
      "hint": "Used to access global or class-level members",
      "explanation": "The scope resolution operator (::) in C++ is used to access variables, functions, and members that are members of a namespace or class. It can also be used to access global variables when shadowed by local variables.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Easy",
      "related_section": "3.1 - C Programming Fundamentals",
      "keywords": ["scope resolution operator", "::", "namespace", "class"]
    },
    {
      "id": 34,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a friend function in C++?",
      "options": [
        "A function that is a member of a class",
        "A function that has access to private members of a class without being a member",
        "A function that inherits from a class",
        "A function that is declared in another class"
      ],
      "correct_answer": "A function that has access to private members of a class without being a member",
      "hint": "Friend functions break encapsulation for specific purposes",
      "explanation": "A friend function in C++ is a function that is not a member of a class but has access to the private and protected members of that class. It is declared using the 'friend' keyword inside the class. Friend functions are useful for allowing external functions to access class internals.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Hard",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["friend function", "private access", "encapsulation"]
    },
    {
      "id": 35,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is the difference between public and protected access specifiers?",
      "options": [
        "Public is accessible from anywhere, protected is accessible only from derived classes",
        "Protected is more restrictive than public",
        "They are the same",
        "Public is for variables, protected is for functions"
      ],
      "correct_answer": "Public is accessible from anywhere, protected is accessible only from derived classes",
      "hint": "Protected allows inheritance access",
      "explanation": "Public access specifier allows members to be accessed from anywhere (both inside and outside the class). Protected access specifier allows members to be accessed from derived classes and within the class, but not from outside.",
      "source": "Set 2 (Aasadh, 2081) - Short Questions",
      "difficulty": "Medium",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["public", "protected", "private", "access specifier"]
    },
    {
      "id": 36,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a copy constructor?",
      "options": [
        "A constructor that copies a class into a namespace",
        "A constructor that creates a copy of an object",
        "A constructor that inherits from another class",
        "A constructor that deletes an object"
      ],
      "correct_answer": "A constructor that creates a copy of an object",
      "hint": "Copy constructor is called when creating a copy of an object",
      "explanation": "A copy constructor is a member function that creates a new object as a copy of an existing object. It takes a const reference to an object of the same class as a parameter. If a copy constructor is not explicitly defined, the compiler generates a default one.",
      "source": "Set 1 (Chaitra, 2080) - Long Questions",
      "difficulty": "Hard",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["copy constructor", "object copy", "deep copy", "shallow copy"]
    },
    {
      "id": 37,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is abstraction?",
      "options": [
        "Hiding implementation details and showing only functionality",
        "Creating multiple objects of a class",
        "Inheriting from a base class",
        "Overloading operators"
      ],
      "correct_answer": "Hiding implementation details and showing only functionality",
      "hint": "Abstraction provides an interface",
      "explanation": "Abstraction is the concept of hiding implementation details and showing only the necessary functionality to the user. In C++, abstraction is achieved using abstract classes and interfaces. Abstract classes contain pure virtual functions that must be implemented by derived classes.",
      "source": "Set 3 (Asojh, 2080) - Short Questions",
      "difficulty": "Medium",
      "related_section": "3.3 - C++ Basics and Classes",
      "keywords": ["abstraction", "abstract class", "pure virtual function"]
    },
    {
      "id": 38,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the difference between an array and a pointer?",
      "options": [
        "Arrays store multiple values, pointers store addresses",
        "Pointers are faster than arrays",
        "Arrays cannot be passed to functions",
        "Pointers are safer than arrays"
      ],
      "correct_answer": "Arrays store multiple values, pointers store addresses",
      "hint": "Arrays vs memory addresses",
      "explanation": "Arrays store multiple values of the same type in contiguous memory locations, while pointers store memory addresses. Arrays have fixed size, while pointers can point to different locations dynamically. When an array is passed to a function, it decays to a pointer.",
      "source": "Model Set - Computer Engineering by NEC",
      "difficulty": "Medium",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["array", "pointer", "memory", "address"]
    },
    {
      "id": 39,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is the purpose of the delete operator in C++?",
      "options": [
        "To free memory allocated with new",
        "To remove a variable from scope",
        "To delete a file",
        "To remove an element from an array"
      ],
      "correct_answer": "To free memory allocated with new",
      "hint": "Deallocates heap memory",
      "explanation": "The delete operator in C++ is used to free memory that was previously allocated using the new operator. It calls destructors for objects and deallocates the memory. Using delete is important to prevent memory leaks.",
      "source": "Set 2 (Aasadh, 2081) - Short Questions",
      "difficulty": "Easy",
      "related_section": "3.2 - Pointers and Structures",
      "keywords": ["delete", "memory deallocation", "new", "heap"]
    },
    {
      "id": 40,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the STL in C++?",
      "options": [
        "Standard Template Library - a collection of template classes and functions",
        "Standard Type Linker",
        "System Template Language",
        "Static Type Library"
      ],
      "correct_answer": "Standard Template Library - a collection of template classes and functions",
      "hint": "Includes containers, algorithms, and iterators",
      "explanation": "The STL (Standard Template Library) is a library in C++ that provides a collection of template classes and functions for containers (vector, list, map), algorithms (sort, find), and iterators. STL provides reusable components that follow generic programming principles.",
      "source": "Set 1 (Chaitra, 2080) - Long Questions",
      "difficulty": "Medium",
      "related_section": "3.6 - Templates and Exception Handling",
      "keywords": ["STL", "containers", "algorithms", "iterators", "template"]
    }
  ]
}
