[
  {
    "id": 101,
    "question": "Which access specifier allows members to be accessible within the same class and child classes?",
    "options": ["Public", "Private", "Protected", "Internal"],
    "correct_answer": "Protected",
    "hint": "This access specifier is more restrictive than public but allows access in derived classes. What is it?",
    "explanation": "Protected is the access specifier that allows members to be accessible within the same class and child classes (derived classes). Members declared as protected cannot be accessed from outside the class or its derived classes, making them more restrictive than public but more permissive than private. This is crucial for inheritance because it allows base classes to provide implementation details to derived classes without exposing them to the outside world. Protected members are often used for implementation details that subclasses need to override or use.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 102,
    "question": "What is the purpose of the cache replacement policy?",
    "options": ["To determine which data to store in the cache", "To determine which data to evict from the cache when space is needed", "To determine how many levels of cache to use", "To determine which data to store in RAM"],
    "correct_answer": "To determine which data to evict from the cache when space is needed",
    "hint": "When cache is full and new data arrives, what decision must be made about existing cache data?",
    "explanation": "The purpose of cache replacement policy is to determine which data to evict from the cache when space is needed. When the cache is full and new data must be brought in, a replacement policy decides which existing cache entry should be removed. Common cache replacement policies include LRU (Least Recently Used), FIFO (First In First Out), LFU (Least Frequently Used), and Optimal. The choice of replacement policy significantly impacts cache performance. A good replacement policy minimizes cache misses by keeping frequently accessed data in the cache.",
    "chapter": "Chapter 4: Computer Organization",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 103,
    "question": "In Direct Memory Access (DMA), what is cycle stealing?",
    "options": ["A method of accessing memory without CPU intervention", "A technique where the DMA controller takes over the bus for one clock cycle to transfer data", "A process of stealing data from protected memory regions", "A mechanism to prevent unauthorized memory access"],
    "correct_answer": "A technique where the DMA controller takes over the bus for one clock cycle to transfer data",
    "hint": "DMA allows I/O devices to access memory. What does cycle stealing mean in this context?",
    "explanation": "Cycle stealing in DMA is a technique where the DMA controller temporarily takes over the system bus for one clock cycle to transfer data between I/O device and memory, stealing a cycle from the CPU. During this time, the CPU is paused or suspended. Cycle stealing allows I/O operations to proceed concurrently with CPU execution without completely halting the CPU. This improves overall system performance compared to the CPU being completely blocked during I/O operations. The number of cycles stolen depends on the amount of data to transfer.",
    "chapter": "Chapter 4: Computer Organization",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 104,
    "question": "Which protocol is best suited for real-time operating systems in the transport layer?",
    "options": ["TCP", "UDP", "SCTP", "DCCP"],
    "correct_answer": "UDP",
    "hint": "Real-time systems prioritize speed over reliability. Which transport protocol offers lower latency?",
    "explanation": "UDP (User Datagram Protocol) is best suited for real-time operating systems in the transport layer. UDP is connectionless and provides faster, low-latency communication compared to TCP, which has overhead from connection establishment and acknowledgment mechanisms. Real-time systems require predictable, low-latency delivery even at the cost of occasional data loss. TCP provides reliability guarantees but introduces delays unsuitable for time-critical applications. UDP's simplicity and speed make it ideal for real-time systems like robotics, industrial control, and live streaming where timing is more critical than perfect reliability.",
    "chapter": "Chapter 5: Network & Security",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 105,
    "question": "In the TCP/IP model, which protocol is responsible for logical addressing and routing of packets between hosts?",
    "options": ["TCP", "ICMP", "IP", "UDP"],
    "correct_answer": "IP",
    "hint": "This protocol handles the addressing and routing of packets across networks. Which one?",
    "explanation": "IP (Internet Protocol) is the protocol responsible for logical addressing and routing of packets between hosts in the TCP/IP model. IP operates at the Network Layer (Layer 3) and is fundamental to internet communication. It assigns logical addresses (IP addresses) to devices and determines the path (routing) that packets take through networks to reach their destination. IP can route packets through multiple intermediate networks. TCP handles end-to-end communication, ICMP is used for diagnostics, and UDP provides connectionless transport. Without IP, there would be no way to route packets across different networks.",
    "chapter": "Chapter 5: Network & Security",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 106,
    "question": "Which type of firewall examines individual packets (checking source/destination addresses and ports) to make allow/block decisions?",
    "options": ["Application-level firewall", "Packet-filtering firewall", "Stateful-inspection firewall", "Circuit-level gateway"],
    "correct_answer": "Packet-filtering firewall",
    "hint": "This firewall type makes decisions based on packet headers. What is it called?",
    "explanation": "Packet-filtering firewall is the type that examines individual packets by checking source/destination addresses and ports to make allow/block decisions. Packet-filtering firewalls operate at the Network Layer (Layer 3) and examine packet headers. They are simple, fast, and have low overhead but offer limited security compared to more sophisticated firewalls. Stateful-inspection firewalls track connection states. Application-level firewalls examine application layer data. Circuit-level gateways operate at Layer 5. Packet-filtering is the most basic but still widely used firewall approach.",
    "chapter": "Chapter 5: Network & Security",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 107,
    "question": "In three-phase electrical systems, which configuration requires grounding at the neutral point?",
    "options": ["Star configuration", "Delta configuration", "Bridge configuration", "Both star and delta equally"],
    "correct_answer": "Star configuration",
    "hint": "Only one type of 3-phase configuration has a neutral point. Which one?",
    "explanation": "In three-phase electrical systems, the Star (Y) configuration requires grounding at the neutral point. The star configuration has three phases and a common neutral point where all three coils connect. This neutral point is typically grounded to earth for safety and voltage stability. The delta configuration, in contrast, has no neutral point because the three coils form a closed loop. Grounding at the star neutral point provides a reference point for voltage measurements and ensures safety by providing a path for fault currents. This is why star configuration is more common in power distribution systems.",
    "chapter": "Chapter 1: Electrical & Electronics",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 108,
    "question": "Which normal form in database normalization requires that every determinant must be a candidate key?",
    "options": ["First Normal Form (1NF)", "Second Normal Form (2NF)", "Boyce-Codd Normal Form (BCNF)", "Third Normal Form (3NF)"],
    "correct_answer": "Boyce-Codd Normal Form (BCNF)",
    "hint": "This strict normal form requires every determinant to be a candidate key. What is it?",
    "explanation": "Boyce-Codd Normal Form (BCNF) requires that every determinant must be a candidate key. BCNF is a stricter version of 3NF. In BCNF, every non-trivial functional dependency X→Y must have X as a candidate key or superkey. This eliminates anomalies that can still exist in 3NF. BCNF is considered the ideal form for most databases but can sometimes lead to lossless decomposition issues. Most practical databases aim for 3NF as BCNF can be overly restrictive.",
    "chapter": "Chapter 7: Data Structures & OS",
    "difficulty": "difficult",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 109,
    "question": "What coating material is used on the screen of a CRT (Cathode Ray Tube) display?",
    "options": ["Aluminum", "Phosphor", "Silicon", "Copper"],
    "correct_answer": "Phosphor",
    "hint": "CRT screens need a material that glows when hit by electrons. What is it?",
    "explanation": "Phosphor is the coating material used on the screen of a CRT (Cathode Ray Tube) display. The phosphor coating glows (fluoresces) when struck by electrons from the electron beam. Different phosphors have different colors and persistence characteristics. When the electron beam scans across the screen, the phosphor emits light at those points, creating the image. After the beam passes, the phosphor continues to glow briefly (persistence) before fading. This persistence needs to be fast enough to prevent flicker. Phosphor-based displays were the standard for televisions and computer monitors before LCD/LED technology.",
    "chapter": "Chapter 6: Theory, Computation & Graphics",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 110,
    "question": "What is a characteristic of Boyce-Codd Normal Form (BCNF)?",
    "options": ["Eliminates all non-key dependencies", "Eliminates only partial dependencies", "Eliminates transitive dependencies", "Eliminates all non-trivial functional dependencies where the determinant is not a candidate key"],
    "correct_answer": "Eliminates all non-trivial functional dependencies where the determinant is not a candidate key",
    "hint": "BCNF is the strictest normal form. What dependencies does it eliminate?",
    "explanation": "A characteristic of BCNF is that it eliminates all non-trivial functional dependencies where the determinant is not a candidate key. In other words, in BCNF, every determinant must be a candidate key. This is the defining characteristic and the strictest constraint of BCNF. First Normal Form eliminates repeating groups. Second Normal Form eliminates partial dependencies. Third Normal Form eliminates transitive dependencies. BCNF goes beyond 3NF by requiring that every determinant be a candidate key, not just non-key attributes determining other attributes.",
    "chapter": "Chapter 7: Data Structures & OS",
    "difficulty": "difficult",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 111,
    "question": "How many possibilities are there in 3-D reflection planes?",
    "options": ["2", "3", "4", "6"],
    "correct_answer": "3",
    "hint": "In 3D space with X, Y, Z axes, how many principal reflection planes are there?",
    "explanation": "There are 3 possibilities for 3D reflection planes. The three principal reflection planes are: (1) XY-plane - reflects across the plane perpendicular to the Z-axis, (2) YZ-plane - reflects across the plane perpendicular to the X-axis, (3) XZ-plane - reflects across the plane perpendicular to the Y-axis. These are the fundamental reflections in 3D graphics. Any other reflection plane can be derived from these. Reflections across these planes are basic transformations in computer graphics and 3D modeling.",
    "chapter": "Chapter 6: Theory, Computation & Graphics",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 112,
    "question": "Which type of projection is used in isometric drawings?",
    "options": ["Orthographic projection", "Parallel projection", "Perspective projection", "Stereographic projection"],
    "correct_answer": "Parallel projection",
    "hint": "Isometric drawings maintain parallel lines and equal angles. Which projection type?",
    "explanation": "Parallel projection is the type used in isometric drawings. Isometric projection is a form of parallel projection where the three axes are drawn at 120° to each other, and all measurements along the axes are to the same scale. Unlike perspective projection where parallel lines converge to vanishing points, parallel projection maintains all parallel lines as parallel. Isometric drawings are commonly used in technical and engineering drawings because they preserve proportions and are easy to measure. They don't appear as realistic as perspective but are useful for technical documentation.",
    "chapter": "Chapter 6: Theory, Computation & Graphics",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 113,
    "question": "Which of the following is common to all software engineering process models?",
    "options": ["Iterative development cycles", "Requirement analysis and planning", "Fixed timeline and resources", "Waterfall approach for all phases"],
    "correct_answer": "Requirement analysis and planning",
    "hint": "All software projects must start with understanding what needs to be built. What is common to all?",
    "explanation": "Requirement analysis and planning is common to all software engineering process models. Whether using Waterfall, Agile, Spiral, or any other model, every software development project begins with understanding requirements and planning. Different models handle these phases differently (Waterfall upfront, Agile iteratively), but all must address requirements and planning. Iterative cycles are not universal (Waterfall is mostly sequential). Timeline and resources vary greatly. The Waterfall approach is not used in all models. Requirement engineering is the foundational activity that all successful software projects share.",
    "chapter": "Chapter 8: Software Engineering",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 114,
    "question": "Which of the following best describes the commonality across different software engineering strategies?",
    "options": ["Code efficiency", "Sequential phases", "Requirement engineering", "Formal documentation only"],
    "correct_answer": "Requirement engineering",
    "hint": "What aspect is fundamental to all software engineering approaches, regardless of methodology?",
    "explanation": "Requirement engineering best describes the commonality across different software engineering strategies. All software engineering methodologies—whether Waterfall, Agile, DevOps, or others—must perform requirement engineering to understand what the software should do. Code efficiency varies by project. Sequential phases are specific to Waterfall. Formal documentation is not required in all approaches. Requirement engineering encompasses gathering, analyzing, documenting, and validating requirements. It's the common foundation that all software projects build upon, ensuring that developed software meets actual needs.",
    "chapter": "Chapter 8: Software Engineering",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 115,
    "question": "What is the first step in the software development process?",
    "options": ["Design", "Implementation", "Requirement gathering", "Testing"],
    "correct_answer": "Requirement gathering",
    "hint": "Before designing or coding, what must you do first to understand the problem?",
    "explanation": "Requirement gathering is the first step in the software development process. Before any design, implementation, or testing can occur, the project team must understand what the software needs to accomplish. This involves collecting, analyzing, and documenting functional and non-functional requirements from stakeholders. Poor requirement gathering leads to failed projects, rework, and scope creep. A solid foundation of well-understood requirements guides all subsequent development phases. This is why requirement engineering is often considered the most critical phase in software development.",
    "chapter": "Chapter 8: Software Engineering",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 116,
    "question": "INT 3 is used for what purpose?",
    "options": ["Division-by-zero error", "Debugger breakpoint interrupt", "System call invocation", "Hardware interrupt"],
    "correct_answer": "Debugger breakpoint interrupt",
    "hint": "This interrupt is commonly used in debugging software. What does INT 3 trigger?",
    "explanation": "INT 3 is used for debugger breakpoint interrupt. This is a special x86 interrupt that signals a breakpoint to the debugger. When a debugger sets a breakpoint in code, it replaces the original instruction with INT 3 (opcode 0xCC). When execution reaches that point, INT 3 is triggered, causing a debugger exception that allows the debugger to pause execution and inspect program state. INT 3 is also known as the breakpoint interrupt. It's a 1-byte instruction making it ideal for inserting breakpoints without affecting code alignment.",
    "chapter": "Chapter 2: Digital Logic & Microprocessor",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 117,
    "question": "Which of the following UML diagrams is classified as a static diagram?",
    "options": ["Sequence diagram", "Use case diagram", "Collaboration diagram", "State diagram"],
    "correct_answer": "Use case diagram",
    "hint": "Static diagrams represent structure, not behavior or interactions. Which one?",
    "explanation": "Use case diagram is classified as a static diagram in UML. Static diagrams represent the static structure of a system and don't show behavior or interactions over time. Use case diagrams show actors and use cases without temporal sequencing. Sequence diagrams are dynamic (show interaction over time). Collaboration diagrams are dynamic (show communication patterns). State diagrams are dynamic (show state transitions). UML diagrams are divided into structural (static) and behavioral (dynamic) categories. Static diagrams include class diagrams, object diagrams, and use case diagrams.",
    "chapter": "Chapter 8: Software Engineering",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 118,
    "question": "Which of the following testing phases is sometimes called acceptance testing?",
    "options": ["White-box testing", "Grey-box testing", "Alpha testing", "Beta testing"],
    "correct_answer": "Beta testing",
    "hint": "Acceptance testing involves real users testing near-final software. Which phase is this?",
    "explanation": "Beta testing is sometimes called acceptance testing. Beta testing involves real users (external to the development team) testing the software in a real environment before final release. Beta testers verify that the software meets their needs and is acceptable for deployment. Beta testing occurs after alpha testing (internal testing) and is the final stage before release to production. It's a form of user acceptance testing (UAT). Alpha testing is internal. White-box and grey-box refer to testing techniques based on code visibility, not phases.",
    "chapter": "Chapter 8: Software Engineering",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 119,
    "question": "Which data structure is used to implement Breadth First Search (BFS)?",
    "options": ["Stack", "Queue", "Linked List", "Tree"],
    "correct_answer": "Queue",
    "hint": "BFS explores nodes level by level. What FIFO structure enables this?",
    "explanation": "Queue is the data structure used to implement Breadth First Search (BFS). BFS uses a FIFO (First-In-First-Out) queue to explore nodes level by level. Starting from a source node, BFS adds all its unvisited neighbors to the queue. Then it processes the first node in the queue, adds its unvisited neighbors, and continues. This ensures that all nodes at distance k are visited before nodes at distance k+1, providing level-by-level exploration. Stack would implement DFS (Depth-First Search). Linked lists and trees are not data structures for implementing search algorithms but rather the structures being searched.",
    "chapter": "Chapter 7: Data Structures & OS",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 120,
    "question": "What is the function of a fuzzifier in fuzzy logic systems?",
    "options": ["To convert crisp input values into fuzzy sets", "To convert fuzzy sets into crisp output values", "To store fuzzy membership values", "To compare fuzzy rules"],
    "correct_answer": "To convert crisp input values into fuzzy sets",
    "hint": "In fuzzy logic, we convert precise numbers to fuzzy membership values. What does the fuzzifier do?",
    "explanation": "The function of a fuzzifier in fuzzy logic systems is to convert crisp (precise, numerical) input values into fuzzy sets. A crisp input like '25 degrees' is converted to fuzzy sets like 'warm' and 'cool' with membership values (e.g., 0.6 warm, 0.4 cool). The fuzzifier bridges the gap between the real world (precise measurements) and fuzzy logic (linguistic variables). After fuzzy inference, a defuzzifier converts fuzzy output back to crisp values for system control. Fuzzification is the first step in fuzzy logic processing.",
    "chapter": "Chapter 9: AI & Neural Networks",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 121,
    "question": "What does the term 'book value' represent in depreciation calculations?",
    "options": ["The original purchase price of an asset", "The current value of an asset minus accumulated depreciation", "The salvage value of an asset", "The market value of an asset"],
    "correct_answer": "The current value of an asset minus accumulated depreciation",
    "hint": "Book value is what remains after depreciation. What is the formula?",
    "explanation": "Book value represents the current value of an asset minus accumulated depreciation. It's the net value of an asset as shown on a company's balance sheet. The formula is: Book Value = Original Cost - Accumulated Depreciation. Book value decreases over time as an asset depreciates. It's called 'book value' because it represents the value recorded in accounting books. Book value differs from market value (actual resale price) and salvage value (expected value at end of useful life). Book value is used for accounting and financial reporting purposes.",
    "chapter": "Chapter 10: Engineering Projects",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 122,
    "question": "What is the process of swapping in operating systems?",
    "options": ["Exchanging data between two registers", "Transferring a process between main memory and secondary storage", "Switching between multiple processes", "Copying data from cache to main memory"],
    "correct_answer": "Transferring a process between main memory and secondary storage",
    "hint": "Swapping moves entire processes between RAM and disk. What is this process?",
    "explanation": "Swapping in operating systems is the process of transferring an entire process (including its code, data, and stack) between main memory (RAM) and secondary storage (hard disk). When memory is needed, the OS swaps out a less-used process to disk, freeing RAM for other processes. When the swapped-out process is needed, it's swapped back into RAM. Swapping enables systems to run processes larger than physical memory and to manage limited memory resources. However, swapping is slow due to disk I/O. Paging is a related but more efficient technique that swaps memory pages rather than entire processes.",
    "chapter": "Chapter 7: Data Structures & OS",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 123,
    "question": "In which year was the latest Nepal Engineering Council Act established?",
    "options": ["1992", "2002", "2012", "2022"],
    "correct_answer": "1992",
    "hint": "The Nepal Engineering Council Act was established in the 1990s. Which specific year?",
    "explanation": "The latest Nepal Engineering Council Act was established in 1992. This act provides the legal framework for the Nepal Engineering Council to regulate and promote the engineering profession in Nepal. The NEC was established to ensure quality engineering practice, register engineers, maintain professional standards, and protect public interest. The 1992 Act remains the primary legislation governing NEC operations. Various amendments and regulations have been introduced since then, but 1992 is the year of the foundational Act.",
    "chapter": "Chapter 10: Engineering Projects",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 124,
    "question": "Which of the following is a passive circuit element?",
    "options": ["Voltage source", "Current source", "Resistor", "Transformer"],
    "correct_answer": "Resistor",
    "hint": "Passive elements don't supply energy. Which one only dissipates energy?",
    "explanation": "A resistor is a passive circuit element. Passive elements are components that either dissipate or store energy but do not supply energy. A resistor dissipates electrical energy as heat (Joule heating). In contrast, voltage sources and current sources are active elements that supply energy to circuits. A transformer can be passive (just transferring energy) or active depending on configuration, but in standard form is considered a two-port passive element. Other passive elements include capacitors and inductors which store energy. The distinction between active and passive elements is fundamental to circuit analysis.",
    "chapter": "Chapter 1: Electrical & Electronics",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 125,
    "question": "What is the general efficiency formula for a Class A amplifier?",
    "options": ["25%", "50%", "75%", "88.5%"],
    "correct_answer": "25%",
    "hint": "Class A amplifiers have the lowest efficiency among amplifier classes. What is their theoretical maximum?",
    "explanation": "The general efficiency formula for a Class A amplifier is 25% (theoretical maximum is π/4 ≈ 78.5%, but practical efficiency is around 25%). Class A amplifiers conduct for the entire 360° of the input signal, so the output transistor is always consuming power, even when not amplifying the signal. This results in significant power dissipation as heat. Most of the input power is wasted as heat rather than converted to useful output. Despite low efficiency, Class A amplifiers are valued for their linear characteristics and low distortion. Class B (50%), Class AB (~60%), and Class D (>90%) have better efficiency.",
    "chapter": "Chapter 1: Electrical & Electronics",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 126,
    "question": "For fast addition of two 4-bit binary numbers, how many half adders and full adders are required?",
    "options": ["2 half adders and 2 full adders", "1 half adder and 3 full adders", "3 full adders and 1 half adder", "4 full adders and 0 half adders"],
    "correct_answer": "1 half adder and 3 full adders",
    "hint": "The first bit position uses a different adder type than subsequent positions. How many of each?",
    "explanation": "For fast addition of two 4-bit binary numbers, 1 half adder and 3 full adders are required. The half adder is used for the least significant bit (LSB) position because there's no carry-in from a previous position. Each of the remaining 3 positions uses a full adder to process the two input bits plus the carry-in from the previous position. A half adder takes 2 inputs and produces 2 outputs (sum and carry). A full adder takes 3 inputs (including carry-in) and produces 2 outputs. This configuration is called a ripple carry adder.",
    "chapter": "Chapter 2: Digital Logic & Microprocessor",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 127,
    "question": "In assembly language, what type of addressing mode is used in the instruction MOV A, M?",
    "options": ["Register addressing", "Indirect register addressing", "Direct addressing", "Immediate addressing"],
    "correct_answer": "Indirect register addressing",
    "hint": "M typically represents memory address stored in a register. What addressing mode is this?",
    "explanation": "The instruction MOV A, M uses indirect register addressing mode. In this mode, the memory address is stored in a register (M typically refers to the address in the HL register pair or a similar register). The instruction fetches data from the memory address stored in the register and moves it to register A. Indirect addressing is useful for accessing arrays or dynamic data structures where the address is determined at runtime. Direct addressing would specify the address explicitly. Immediate addressing would have the data value directly. Register addressing would move from one register to another.",
    "chapter": "Chapter 2: Digital Logic & Microprocessor",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 128,
    "question": "When a derived class inherits from a base class, which constructor is executed first?",
    "options": ["Derived class constructor only", "Base class constructor, then derived class constructor", "Derived class constructor, then base class constructor", "Both constructors are executed simultaneously"],
    "correct_answer": "Base class constructor, then derived class constructor",
    "hint": "Constructor execution follows a specific order in inheritance. What is the sequence?",
    "explanation": "When a derived class inherits from a base class, the base class constructor is executed first, then the derived class constructor. This order ensures that the base class object is properly initialized before the derived class initializes its additional members. If the base class constructor isn't called explicitly, the compiler calls a default or implicit constructor. This initialization order is important because the derived class might depend on proper initialization of inherited members. The reverse order (destructors) applies in reverse - derived class destructor first, then base class destructor.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 129,
    "question": "What is an exception in object-oriented programming?",
    "options": ["A special function", "A type of inheritance", "A method", "A class"],
    "correct_answer": "A special function",
    "hint": "Exceptions are abnormal conditions during program execution. What are they?",
    "explanation": "An exception in object-oriented programming is a special function or mechanism that handles abnormal conditions during program execution. When an error or exceptional situation occurs, an exception is thrown, interrupting normal program flow. The program then jumps to exception handlers (catch blocks) that deal with the problem. Exceptions allow graceful error handling instead of program crashes. They're not a type of inheritance, method, or regular class, but rather a control flow mechanism. Exception handling improves program robustness and maintainability by separating error handling code from normal logic.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 130,
    "question": "For faster data access in a computer system, which component should be prioritized?",
    "options": ["Hard disk", "RAM", "Cache memory", "Secondary storage"],
    "correct_answer": "Cache memory",
    "hint": "The fastest but most expensive memory. What is it?",
    "explanation": "Cache memory should be prioritized for faster data access in a computer system. Cache memory is extremely fast (accessing data in nanoseconds) but expensive, so it's limited in size. The memory hierarchy prioritizes: (1) CPU registers (fastest, smallest), (2) L1 Cache, (3) L2/L3 Cache, (4) RAM (slower, larger), (5) Disk (slowest, largest). Cache stores frequently accessed data and instructions, reducing average access time dramatically. Hard disk is slowest. Secondary storage is even slower than hard disk. Effective cache usage through cache optimization techniques significantly improves system performance.",
    "chapter": "Chapter 4: Computer Organization",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 131,
    "question": "Which type of transformation changes the shape of an object?",
    "options": ["Translation", "Rotation", "Scaling", "Shear"],
    "correct_answer": "Shear",
    "hint": "Most transformations preserve shape. Which one distorts it?",
    "explanation": "Shear is the type of transformation that changes the shape of an object. In a shear transformation, one or more coordinates of points are displaced proportionally to other coordinates. Translation moves objects without changing shape or size. Rotation turns objects without changing shape or size. Scaling changes size but preserves proportions (shape). Only shear actually distorts and changes the shape of an object. Shear is used in graphics to create italic/slanted text, skew effects, and perspective corrections. The amount of shear is determined by a shear parameter.",
    "chapter": "Chapter 6: Theory, Computation & Graphics",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 132,
    "question": "Which object-oriented programming (OOP) concept involves bundling data and methods within a single class to protect them from outside interference?",
    "options": ["Polymorphism", "Inheritance", "Encapsulation", "Abstraction"],
    "correct_answer": "Encapsulation",
    "hint": "Bundling data and methods together for protection. What is this concept?",
    "explanation": "Encapsulation is the OOP concept that involves bundling data and methods within a single class to protect them from outside interference. Encapsulation uses access specifiers (public, private, protected) to control what's accessible from outside the class. This hides internal implementation details and prevents unintended modification of object state. Encapsulation promotes data hiding and provides a controlled interface (public methods) for interacting with objects. Polymorphism deals with multiple forms. Inheritance deals with parent-child relationships. Abstraction deals with hiding complexity.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 133,
    "question": "What is the main advantage of hybrid inheritance?",
    "options": ["Code reusability", "Reduced memory usage", "Faster compilation", "Simpler syntax"],
    "correct_answer": "Code reusability",
    "hint": "Hybrid inheritance combines multiple inheritance types. What's the primary benefit?",
    "explanation": "The main advantage of hybrid inheritance is code reusability. Hybrid inheritance combines multiple inheritance types (single, multilevel, multiple, hierarchical) to leverage features from multiple base classes. This allows a derived class to inherit code and functionality from multiple sources, reducing code duplication and promoting modularity. With proper design using hybrid inheritance, developers can build complex class hierarchies that maximize code reuse. While hybrid inheritance is powerful, it can introduce complexity (diamond problem) if not carefully designed. Languages like C++ support hybrid inheritance; some languages like Java restrict it to avoid these complications.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 134,
    "question": "The A* search algorithm uses which search strategy?",
    "options": ["Depth-first search", "Breadth-first search", "Best-first search", "Depth-limited search"],
    "correct_answer": "Best-first search",
    "hint": "A* combines actual cost and heuristic estimate to guide search. What strategy is this?",
    "explanation": "The A* search algorithm uses best-first search strategy. A* evaluates nodes using f(n) = g(n) + h(n), where g(n) is the actual cost from start node and h(n) is the heuristic estimate to goal. This hybrid approach combines the optimality of Dijkstra's algorithm with the speed of greedy best-first search. A* always expands the most promising node first (best-first strategy), leading to optimal pathfinding when the heuristic is admissible. A* is widely used in game AI, robotics, and navigation systems.",
    "chapter": "Chapter 9: AI & Neural Networks",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 135,
    "question": "Which of the following statements is true about static functions in C++?",
    "options": ["Static functions can be overloaded", "Static functions cannot be overloaded", "Static functions are implicitly virtual", "Static functions can access instance variables"],
    "correct_answer": "Static functions cannot be overloaded",
    "hint": "Static functions belong to the class, not instances. Can they be overloaded?",
    "explanation": "Static functions cannot be overloaded in C++. Since static functions belong to the class itself rather than instances, function resolution is based on the class and function name alone. Without instance information, the compiler cannot distinguish between overloaded static functions based on parameter types alone in all contexts. Non-static functions can be overloaded within a class hierarchy through polymorphism. Static functions cannot be virtual because they're not polymorphic. Static functions cannot access instance variables because they don't have an instance context.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 136,
    "question": "In the Standard Template Library (STL), what do containers primarily hold?",
    "options": ["Functions and algorithms", "Data elements and their organization", "Iterators and pointers only", "Memory addresses"],
    "correct_answer": "Data elements and their organization",
    "hint": "STL containers are data structures. What do they store and manage?",
    "explanation": "In the Standard Template Library (STL), containers primarily hold data elements and their organization. Containers are template classes that manage collections of data with different organizational structures (vector, list, queue, stack, map, etc.). Each container type organizes data differently to optimize specific operations. Containers provide iterators for traversing elements and algorithms operate on container data through iterators. Functions and algorithms are separate STL components. Iterators are access mechanisms, not what containers hold. Memory addresses are implementation details, not the primary purpose.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 137,
    "question": "Which component of an operating system kernel manages process execution and resource allocation?",
    "options": ["File manager", "Memory manager", "Process scheduler", "Device driver"],
    "correct_answer": "Process scheduler",
    "hint": "This OS component decides which process runs when. What is it?",
    "explanation": "The process scheduler is the OS kernel component that manages process execution and resource allocation. It decides which process should run next, for how long (time slice/quantum), and allocates CPU time among competing processes. The scheduler implements scheduling algorithms like Round-Robin, Priority-Based, or SJF. Process scheduling is critical for system responsiveness and throughput. File manager handles file operations. Memory manager handles memory allocation. Device drivers handle hardware communication.",
    "chapter": "Chapter 7: Data Structures & OS",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 138,
    "question": "What is the tenure of the Registrar of Nepal Engineering Council?",
    "options": ["2 years", "3 years", "4 years", "5 years"],
    "correct_answer": "4 years",
    "hint": "NEC positions have specific tenure periods. The Registrar serves for how long?",
    "explanation": "The tenure of the Registrar of Nepal Engineering Council is 4 years. The Registrar is responsible for day-to-day operations of NEC and reports to the President or Executive Committee. The 4-year term provides enough continuity while preventing indefinite tenure. After 4 years, the position can be refilled through a recruitment process. The Registrar's responsibilities include maintaining records, processing engineering licenses, and coordinating between different NEC departments.",
    "chapter": "Chapter 10: Engineering Projects",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 139,
    "question": "Which activation function is commonly used in Hopfield neural networks?",
    "options": ["ReLU", "Sigmoid", "Sign function", "Softmax"],
    "correct_answer": "Sign function",
    "hint": "Hopfield networks produce binary outputs. What activation function enables this?",
    "explanation": "The sign function is the activation function commonly used in Hopfield neural networks. The sign function outputs +1 or -1 (binary values) based on whether the input is positive or negative. Hopfield networks are recurrent neural networks used for pattern recognition and associative memory. The sign function (also called threshold or step function) enables Hopfield networks to converge to stable states that represent stored patterns. ReLU and Sigmoid produce continuous values. Softmax produces probability distributions. The binary nature of the sign function is essential for Hopfield network operation.",
    "chapter": "Chapter 9: AI & Neural Networks",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 140,
    "question": "Which of the following is an example of unsupervised learning?",
    "options": ["Decision tree learning", "Support vector machines", "K-means clustering", "Neural network classification"],
    "correct_answer": "K-means clustering",
    "hint": "Unsupervised learning finds patterns without labeled data. Which is an example?",
    "explanation": "K-means clustering is an example of unsupervised learning. K-means finds natural groupings (clusters) in unlabeled data by minimizing within-cluster variance. It requires no labeled training data, only input data points. Decision trees, SVMs, and neural networks for classification are supervised learning methods that require labeled training data. K-means is used for customer segmentation, image compression, and pattern discovery. Other unsupervised learning examples include hierarchical clustering, DBSCAN, and principal component analysis (PCA).",
    "chapter": "Chapter 9: AI & Neural Networks",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 141,
    "question": "According to the Church-Turing thesis, what can be computed by a Turing machine?",
    "options": ["Only deterministic problems", "Anything that is algorithmically computable", "Only problems with polynomial time complexity", "Only finite state problems"],
    "correct_answer": "Anything that is algorithmically computable",
    "hint": "The Church-Turing thesis defines computational limits. What can be computed?",
    "explanation": "According to the Church-Turing thesis, a Turing machine can compute anything that is algorithmically computable. This thesis (though not formally proven, widely accepted) states that any computation that can be done by any algorithm can be simulated by a Turing machine. It's the foundation for understanding computational theory and the limits of computation. The thesis doesn't restrict to deterministic, polynomial-time, or finite-state problems. It establishes that Turing machines represent the ultimate model of computation—any more powerful model hasn't been discovered.",
    "chapter": "Chapter 6: Theory, Computation & Graphics",
    "difficulty": "difficult",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 142,
    "question": "Which feature is NOT supported by IPv6?",
    "options": ["Multicast", "Unicast", "Broadcast", "Anycast"],
    "correct_answer": "Broadcast",
    "hint": "IPv6 removed one communication mode from IPv4. Which one?",
    "explanation": "Broadcast is NOT supported by IPv6. IPv6 removed broadcast communication, which was in IPv4. Instead, IPv6 uses multicast for one-to-many communication. Unicast (one-to-one) and anycast (one-to-nearest) are supported in IPv6. This change reduces unnecessary network traffic since multicast and anycast are more efficient than broadcast. In IPv6, if all-nodes communication is needed, all-nodes multicast address is used instead of broadcast.",
    "chapter": "Chapter 5: Network & Security",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 143,
    "question": "What type of memory interface does USB typically use?",
    "options": ["SRAM", "DRAM", "Flash memory", "Cache"],
    "correct_answer": "Flash memory",
    "hint": "USB devices like flash drives use what type of non-volatile memory?",
    "explanation": "USB typically uses Flash memory interface. USB flash drives store data in flash memory, which is non-volatile (retains data without power). Flash memory provides fast read/write access suitable for portable storage. The USB interface provides power and communication to the flash memory device. SRAM and DRAM are volatile (lose data without power). Cache is internal to CPUs. Flash memory offers a good balance of speed, capacity, and cost for removable storage media.",
    "chapter": "Chapter 4: Computer Organization",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 144,
    "question": "Which of the following is a characteristic of CISC architecture?",
    "options": ["Large number of simple instructions", "Small number of complex instructions", "Fixed instruction length", "Pipeline efficiency"],
    "correct_answer": "Small number of complex instructions",
    "hint": "CISC has complex instructions. What's the characteristic?",
    "explanation": "A characteristic of CISC (Complex Instruction Set Computer) architecture is a small number of complex instructions. CISC uses powerful instructions that perform multiple operations (like MOV, ADD, and MULTIPLY combined). This reduces program size and memory bandwidth. RISC (Reduced Instruction Set Computer) uses a large number of simple instructions. CISC instructions vary in length. CISC can have pipeline challenges due to instruction complexity. x86 and x64 are CISC architectures. CISC was popular before RISC architectures became dominant for many applications.",
    "chapter": "Chapter 4: Computer Organization",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 145,
    "question": "What is the main advantage of CMOS technology over bipolar technology?",
    "options": ["Higher speed", "Better analog performance", "Lower power consumption and energy efficiency", "Larger circuit size"],
    "correct_answer": "Lower power consumption and energy efficiency",
    "hint": "CMOS is famous for what advantage over older technologies?",
    "explanation": "The main advantage of CMOS technology over bipolar technology is lower power consumption and energy efficiency. CMOS uses complementary transistors (NMOS and PMOS) that conduct alternately, consuming significant power only during switching. Bipolar transistors consume power continuously. CMOS efficiency made it ideal for battery-powered devices, mobile electronics, and low-power applications. CMOS became the dominant technology for digital circuits. While modern bipolar circuits can be competitive in speed, CMOS remains superior in power efficiency and has better scaling properties.",
    "chapter": "Chapter 1: Electrical & Electronics",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 146,
    "question": "What is the process of converting high-level programming language code to machine or assembly level code called?",
    "options": ["Interpretation", "Compilation", "Linking", "Loading"],
    "correct_answer": "Compilation",
    "hint": "Converting source code to lower-level code. What's this process?",
    "explanation": "Compilation is the process of converting high-level programming language code to machine or assembly level code. A compiler reads source code and translates it into executable machine code or intermediate code. Compilation happens before execution. Interpretation executes code line-by-line without pre-translation. Linking combines compiled object files. Loading places executable into memory for execution. Compilation produces standalone executables that run without the compiler. This is why compiled programs run faster than interpreted ones.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 147,
    "question": "How is control maintained on the system bus in a computer architecture?",
    "options": ["On a first-come, first-served basis", "Through priority-based arbitration", "Randomly selected", "Based on memory availability"],
    "correct_answer": "Through priority-based arbitration",
    "hint": "Multiple devices need the bus. How is access controlled?",
    "explanation": "Control on the system bus in a computer architecture is maintained through priority-based arbitration. When multiple devices (CPU, I/O controllers, DMA) need bus access, an arbiter grants access based on priority levels. Devices have different priorities (CPU usually highest). This ensures critical operations get bus access first. Arbitration prevents conflicts and ensures orderly sharing of the shared resource. Some systems use round-robin or other arbitration schemes, but priority-based is most common for performance and reliability.",
    "chapter": "Chapter 4: Computer Organization",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 148,
    "question": "When NPV and IRR are calculated independently for a project, what result is typically obtained?",
    "options": ["NPV and IRR give conflicting results", "NPV and IRR give the same result", "NPV is always higher than IRR", "IRR is always higher than NPV"],
    "correct_answer": "NPV and IRR give the same result",
    "hint": "Both metrics evaluate project viability. Do they usually agree or conflict?",
    "explanation": "When NPV and IRR are calculated independently for a project, NPV and IRR typically give the same result (both accept or both reject a project). This occurs for conventional projects with initial investment followed by positive cash flows. Both methods use the same cash flow information and should lead to the same accept/reject decision in most cases. However, conflicts can arise in special situations like mutually exclusive projects or unconventional cash flows. For independent projects with normal cash flows, if NPV > 0, then IRR > discount rate, leading to the same decision.",
    "chapter": "Chapter 10: Engineering Projects",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 149,
    "question": "When two sinusoidal waves of the same frequency but different amplitude and phase are subtracted, what is the result?",
    "options": ["A sinusoidal wave with the same frequency", "A cosine wave", "A square wave", "A constant value"],
    "correct_answer": "A sinusoidal wave with the same frequency",
    "hint": "Subtracting sinusoids of the same frequency produces what?",
    "explanation": "When two sinusoidal waves of the same frequency but different amplitude and phase are subtracted, the result is a sinusoidal wave with the same frequency. The resulting amplitude and phase depend on the amplitudes and phases of the original waves. This follows from phasor arithmetic: if you subtract two phasors at the same frequency, you get another phasor at that frequency. The resulting wave has different amplitude and phase than either original wave, but same frequency. This property is fundamental to AC circuit analysis and signal processing.",
    "chapter": "Chapter 1: Electrical & Electronics",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 150,
    "question": "What is the postfix notation of the infix expression (A+B)*C?",
    "options": ["AB+C*", "ABC+*", "A+BC*", "CAB+*"],
    "correct_answer": "AB+C*",
    "hint": "Convert infix to postfix: operators come after operands. What is it?",
    "explanation": "The postfix notation of the infix expression (A+B)*C is AB+C*. In postfix notation (Reverse Polish Notation), operators appear after their operands. To convert (A+B)*C to postfix: (1) A and B are operands, A B, (2) + operator comes after A and B, so AB+, (3) The result (A+B) is multiplied by C, so AB+ then C and *, giving AB+C*. Postfix notation is useful for expression evaluation using stacks and is used in many calculators and compilers.",
    "chapter": "Chapter 7: Data Structures & OS",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 151,
    "question": "Health monitoring systems, emergency braking systems, and airplane control systems are examples of which type of real-time system?",
    "options": ["Soft real-time systems", "Firm real-time systems", "Hard real-time systems", "Non-real-time systems"],
    "correct_answer": "Hard real-time systems",
    "hint": "These systems must respond within strict time limits or failures are catastrophic. What type?",
    "explanation": "Health monitoring systems, emergency braking systems, and airplane control systems are examples of hard real-time systems. Hard real-time systems have strict timing constraints where missing deadlines can cause catastrophic failures or loss of life. Hard real-time systems must guarantee response within specific time limits 100% of the time. Soft real-time systems (multimedia) have timing constraints but missing deadlines causes degraded performance, not failure. Firm real-time systems (video streaming) miss occasional deadlines but with limited consequences.",
    "chapter": "Chapter 7: Data Structures & OS",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 152,
    "question": "Which function is used to read a single character from the keyboard in C?",
    "options": ["scanf()", "getchar()", "getch()", "gets()"],
    "correct_answer": "getch()",
    "hint": "This function reads one character without pressing Enter. What is it?",
    "explanation": "The getch() function is used to read a single character from the keyboard in C. getch() reads a character without waiting for Enter key, making it useful for immediate input in games and interactive programs. getchar() also reads a single character but waits for Enter. scanf() reads formatted input. gets() reads an entire string (unsafe). getch() is non-standard (mainly for DOS/Windows) but widely used. For portable code, getchar() is preferred.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 153,
    "question": "Which file stream flag in C++ is used to position the file pointer at the start of the file?",
    "options": ["ios::first", "ios::beg", "ios::start", "ios::begin"],
    "correct_answer": "ios::beg",
    "hint": "File seeking position flags. What flag positions at the beginning?",
    "explanation": "The ios::beg file stream flag in C++ is used to position the file pointer at the start of the file. This flag is used with the seek() function: file.seekg(0, ios::beg) positions the pointer at the file's beginning. ios::end positions at the end. ios::cur positions relative to current location. These flags are fundamental to file I/O operations for random access. They work with both input (seekg) and output (seekp) operations.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 154,
    "question": "When applying superposition theorem in circuit analysis, if a dependent source is present, what should be done with it?",
    "options": ["Completely remove the dependent source", "Replace it with its internal resistance", "Keep the dependent source active", "Replace it with an open circuit"],
    "correct_answer": "Keep the dependent source active",
    "hint": "Dependent sources depend on other circuit variables. How do we handle them in superposition?",
    "explanation": "When applying superposition theorem in circuit analysis, if a dependent source is present, it should be kept active. Dependent sources (voltage-controlled, current-controlled) depend on voltages or currents elsewhere in the circuit. Unlike independent sources which are deactivated (replaced with short for voltage sources, open for current sources) during superposition analysis, dependent sources must remain active because their output depends on the circuit variables. This is a key difference in applying superposition when dependent sources are present.",
    "chapter": "Chapter 1: Electrical & Electronics",
    "difficulty": "medium",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  },
  {
    "id": 155,
    "question": "Which C++ header file must be included to use the ifstream class for file input?",
    "options": ["<iostream>", "<fstream>", "<stdio.h>", "<iomanip>"],
    "correct_answer": "<fstream>",
    "hint": "File stream classes (ifstream, ofstream, fstream) are in which header?",
    "explanation": "The <fstream> header file must be included to use the ifstream class for file input in C++. fstream stands for file stream and contains the file stream classes: ifstream (input), ofstream (output), and fstream (both). iostream contains console I/O classes (cin, cout). stdio.h is C-style file I/O. iomanip provides formatting manipulators. Including <fstream> provides all necessary file I/O functionality.",
    "chapter": "Chapter 3: Programming Languages",
    "difficulty": "easy",
    "marks": 1,
    "source": "NEC Exam Experience - January 9, 2026"
  }
]
