{
  "chapter": "8. Software Engineering and Object-Oriented Analysis & Design",
  "chapter_code": "ACtE08",
  "total_questions": 28,
  "summary": "Covers software development lifecycle, design methodologies, testing strategies, quality management, OOP principles, and design patterns.",
  "subsections": [
    {"section": "8.1 - Software Process Models", "topic_code": "ACtE0801", "question_count": 5},
    {"section": "8.2 - Software Design and Architecture", "topic_code": "ACtE0802", "question_count": 5},
    {"section": "8.3 - Testing and Quality Assurance", "topic_code": "ACtE0803", "question_count": 5},
    {"section": "8.4 - Object-Oriented Principles", "topic_code": "ACtE0804", "question_count": 5},
    {"section": "8.5 - OOP Design and Patterns", "topic_code": "ACtE0805", "question_count": 4},
    {"section": "8.6 - Project Management", "topic_code": "ACtE0806", "question_count": 4}
  ],
  "questions": [
    {
      "id": 1,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "Which software development model is the oldest approach?",
      "options": ["Agile", "Waterfall", "Spiral", "DevOps"],
      "correct_answer": "Waterfall",
      "hint": "Sequential phases flowing like water",
      "explanation": "The Waterfall model is the oldest structured approach, introduced in the 1970s. It divides development into sequential phases: requirements, design, implementation, testing, and maintenance.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Easy",
      "related_section": "8.1 - Software Process Models",
      "keywords": ["Waterfall", "SDLC", "sequential", "model"]
    },
    {
      "id": 2,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "In which software development model is risk management prominently featured?",
      "options": ["Agile", "Iterative", "Spiral", "Waterfall"],
      "correct_answer": "Spiral",
      "hint": "This model emphasizes risk analysis in each iteration",
      "explanation": "The Spiral model features risk management prominently in each iteration. It combines waterfall's structured phases with iterative prototyping and includes risk analysis as a core component.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "8.1 - Software Process Models",
      "keywords": ["Spiral model", "risk management", "iteration", "prototyping"]
    },
    {
      "id": 3,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "Which software development model is difficult to maintain?",
      "options": ["Agile", "Iterative", "Spiral", "Waterfall"],
      "correct_answer": "Waterfall",
      "hint": "Sequential phases make changes difficult",
      "explanation": "Waterfall is difficult to maintain because changes must go back through earlier phases. Once a phase is complete, returning to modify it is costly and time-consuming.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "8.1 - Software Process Models",
      "keywords": ["Waterfall", "maintenance", "changes", "sequential"]
    },
    {
      "id": 4,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What are the main advantages of Agile methodology?",
      "options": ["Flexibility, iterative delivery, continuous feedback, early value", "Only planning", "Documentation only", "No testing"],
      "correct_answer": "Flexibility, iterative delivery, continuous feedback, early value",
      "hint": "Responds well to changing requirements",
      "explanation": "Agile advantages: flexibility to accommodate changes, iterative delivery of working software, continuous customer feedback, and early delivery of business value.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "8.1 - Software Process Models",
      "keywords": ["Agile", "flexibility", "iterative", "customer feedback"]
    },
    {
      "id": 5,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a software design pattern?",
      "options": ["Code pattern", "Reusable solution to common design problems", "Design documentation", "Testing pattern"],
      "correct_answer": "Reusable solution to common design problems",
      "hint": "Similar to building architecture patterns",
      "explanation": "A design pattern is a reusable solution to a common problem in software design. Patterns provide proven templates for solving recurring design issues (e.g., Singleton, Factory, Observer).",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Easy",
      "related_section": "8.5 - OOP Design and Patterns",
      "keywords": ["design pattern", "reusable", "solution", "template"]
    },
    {
      "id": 6,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the main purpose of unit testing?",
      "options": ["Test entire system", "Test individual components in isolation", "User acceptance testing", "Performance testing"],
      "correct_answer": "Test individual components in isolation",
      "hint": "Tests smallest testable units",
      "explanation": "Unit testing tests individual functions/methods in isolation to verify they work correctly. It's the first level of testing and catches bugs early.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Easy",
      "related_section": "8.3 - Testing and Quality Assurance",
      "keywords": ["unit test", "component", "isolation", "verification"]
    },
    {
      "id": 7,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is integration testing?",
      "options": ["Testing individual units", "Testing interaction between integrated components", "Testing UI", "Final testing"],
      "correct_answer": "Testing interaction between integrated components",
      "hint": "Tests how components work together",
      "explanation": "Integration testing verifies that different components/modules work together correctly. It identifies interface and interaction issues between components.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Easy",
      "related_section": "8.3 - Testing and Quality Assurance",
      "keywords": ["integration test", "components", "interaction", "interface"]
    },
    {
      "id": 8,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a software architecture?",
      "options": ["Building design", "High-level structure describing components and relationships", "Code structure", "Database design"],
      "correct_answer": "High-level structure describing components and relationships",
      "hint": "Blueprint of the software system",
      "explanation": "Software architecture describes the high-level structure of a system, defining major components, their responsibilities, and interactions. It guides design and implementation decisions.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "8.2 - Software Design and Architecture",
      "keywords": ["architecture", "components", "structure", "design"]
    },
    {
      "id": 9,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is object-oriented analysis?",
      "options": ["Hardware analysis", "Identifying objects and their interactions in problem domain", "Code analysis", "Performance analysis"],
      "correct_answer": "Identifying objects and their interactions in problem domain",
      "hint": "Focuses on 'what' not 'how'",
      "explanation": "OOP analysis identifies objects, their attributes, methods, and interactions in the problem domain. It creates a model of real-world entities and their relationships.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "8.4 - Object-Oriented Principles",
      "keywords": ["OOP analysis", "objects", "attributes", "methods"]
    },
    {
      "id": 10,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What are the three main OOP principles?",
      "options": ["Encapsulation, Inheritance, Polymorphism", "Abstraction, Inheritance, Composition", "Only Encapsulation", "Variables, Functions, Classes"],
      "correct_answer": "Encapsulation, Inheritance, Polymorphism",
      "hint": "EIP - fundamental OOP concepts",
      "explanation": "Main OOP principles: Encapsulation (data hiding), Inheritance (code reuse), Polymorphism (multiple forms). These are foundational to object-oriented design.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Easy",
      "related_section": "8.4 - Object-Oriented Principles",
      "keywords": ["OOP", "encapsulation", "inheritance", "polymorphism"]
    },
    {
      "id": 11,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a use case diagram?",
      "options": ["Database diagram", "Diagram showing actors and interactions with system", "Class diagram", "State diagram"],
      "correct_answer": "Diagram showing actors and interactions with system",
      "hint": "Shows functionality from user perspective",
      "explanation": "A use case diagram represents system functionality from the user's perspective. It shows actors (users/systems) and their interactions with the system.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Easy",
      "related_section": "8.5 - OOP Design and Patterns",
      "keywords": ["use case", "actor", "interaction", "UML"]
    },
    {
      "id": 12,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a class diagram in UML?",
      "options": ["Classroom layout", "Shows classes and their relationships", "State transitions", "Use case diagram"],
      "correct_answer": "Shows classes and their relationships",
      "hint": "Describes structure of object-oriented system",
      "explanation": "A class diagram shows classes, attributes, methods, and relationships (inheritance, association, composition). It's the primary diagram for OOP design documentation.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "8.5 - OOP Design and Patterns",
      "keywords": ["class diagram", "UML", "attributes", "methods", "relationships"]
    },
    {
      "id": 13,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is white box testing?",
      "options": ["Testing without code visibility", "Testing with knowledge of internal code structure", "GUI testing", "Manual testing"],
      "correct_answer": "Testing with knowledge of internal code structure",
      "hint": "Tester knows the internal structure",
      "explanation": "White box testing (or clear box testing) involves testing with knowledge of internal code structure. Tester can examine code paths, branches, and logic.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "8.3 - Testing and Quality Assurance",
      "keywords": ["white box", "code coverage", "unit test", "internal structure"]
    },
    {
      "id": 14,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is black box testing?",
      "options": ["Testing entire system", "Testing without knowledge of internal code", "GUI testing only", "Integration testing"],
      "correct_answer": "Testing without knowledge of internal code",
      "hint": "Focus on inputs and outputs",
      "explanation": "Black box testing tests without knowledge of internal code structure. Focus is on inputs, outputs, and functionality. Common in acceptance and system testing.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "8.3 - Testing and Quality Assurance",
      "keywords": ["black box", "functional testing", "inputs", "outputs"]
    },
    {
      "id": 15,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is a Singleton pattern?",
      "options": ["Single method class", "Design pattern ensuring only one instance exists", "Single inheritance", "Single value variable"],
      "correct_answer": "Design pattern ensuring only one instance exists",
      "hint": "Ensures single global instance",
      "explanation": "Singleton is a creational design pattern that restricts a class to have only one instance globally. Useful for resources like database connections.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "8.5 - OOP Design and Patterns",
      "keywords": ["Singleton", "pattern", "instance", "global"]
    },
    {
      "id": 16,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the Factory pattern?",
      "options": ["Manufacturing process", "Creational pattern for object creation", "Object destruction", "Data storage"],
      "correct_answer": "Creational pattern for object creation",
      "hint": "Creates objects without specifying exact classes",
      "explanation": "Factory pattern is a creational pattern that provides interface for creating objects without specifying their concrete classes. Useful for polymorphic object creation.",
      "source": "Model Set",
      "difficulty": "Medium",
      "related_section": "8.5 - OOP Design and Patterns",
      "keywords": ["Factory", "pattern", "object creation", "polymorphism"]
    },
    {
      "id": 17,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is in a project charter?",
      "options": ["Project goals and scope", "Detailed implementation plan", "Code specifications", "Testing procedures"],
      "correct_answer": "Project goals and scope",
      "hint": "Authorizes and defines the project",
      "explanation": "A project charter outlines project goals, scope, objectives, stakeholders, and authority. It's the foundational document that authorizes the project.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Easy",
      "related_section": "8.6 - Project Management",
      "keywords": ["charter", "project", "scope", "authorization"]
    },
    {
      "id": 18,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the purpose of project scheduling?",
      "options": ["Organize project meetings", "Plan activities, durations, sequences, and dependencies", "Document project", "Test project"],
      "correct_answer": "Plan activities, durations, sequences, and dependencies",
      "hint": "Creates timeline and critical path",
      "explanation": "Project scheduling plans activities, estimates durations, sequences them, and identifies dependencies and critical path. It creates realistic timeline.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "8.6 - Project Management",
      "keywords": ["scheduling", "timeline", "critical path", "activity"]
    },
    {
      "id": 19,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What are the five SOLID principles?",
      "options": ["Single, Open/Closed, Liskov, Interface, Dependency", "System, Object, Logic, Implementation, Design", "Singleton, Override, Library, Interface, Dynamic"],
      "correct_answer": "Single, Open/Closed, Liskov, Interface, Dependency",
      "hint": "S-O-L-I-D acronym",
      "explanation": "SOLID principles: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion. They guide good OOP design.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Hard",
      "related_section": "8.4 - Object-Oriented Principles",
      "keywords": ["SOLID", "principles", "OOP", "design"]
    },
    {
      "id": 20,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a sequence diagram?",
      "options": ["Order of numbers", "UML diagram showing object interactions over time", "Database sequence", "Code sequence"],
      "correct_answer": "UML diagram showing object interactions over time",
      "hint": "Shows message flows between objects",
      "explanation": "A sequence diagram shows how objects/components interact over time. It displays messages passed between objects in a specific sequence, useful for understanding behavior.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Medium",
      "related_section": "8.5 - OOP Design and Patterns",
      "keywords": ["sequence diagram", "UML", "interaction", "message"]
    },
    {
      "id": 21,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is code review?",
      "options": ["Reading code", "Systematic examination of code by peer to find defects", "Code documentation", "Code testing"],
      "correct_answer": "Systematic examination of code by peer to find defects",
      "hint": "Quality assurance practice",
      "explanation": "Code review is a systematic examination of code by peers/colleagues to identify defects, ensure standards, improve quality, and share knowledge.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Easy",
      "related_section": "8.3 - Testing and Quality Assurance",
      "keywords": ["code review", "peer review", "quality", "defects"]
    },
    {
      "id": 22,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is a dummy activity in project networks?",
      "options": ["Unnecessary task", "Theoretical activity with zero duration for logical dependencies", "Difficult task", "Testing activity"],
      "correct_answer": "Theoretical activity with zero duration for logical dependencies",
      "hint": "Used in PERT/CPM charts",
      "explanation": "A dummy activity has zero duration and is used to show logical dependencies between real activities. It helps maintain correct precedence relationships without representing actual work.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Medium",
      "related_section": "8.6 - Project Management",
      "keywords": ["dummy activity", "PERT", "CPM", "network diagram"]
    },
    {
      "id": 23,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is refactoring in software?",
      "options": ["Breaking code", "Restructuring code without changing functionality", "Code documentation", "Code optimization only"],
      "correct_answer": "Restructuring code without changing functionality",
      "hint": "Improves code quality and maintainability",
      "explanation": "Refactoring is restructuring code to improve quality, readability, and maintainability without changing its external behavior. It makes code cleaner and easier to understand.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Easy",
      "related_section": "8.2 - Software Design and Architecture",
      "keywords": ["refactoring", "code quality", "maintainability", "improvement"]
    },
    {
      "id": 24,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What are design patterns classified into?",
      "options": ["Creational, Structural, Behavioral", "Only Creational", "Input, Process, Output", "Primary and Secondary"],
      "correct_answer": "Creational, Structural, Behavioral",
      "hint": "Three main categories of design patterns",
      "explanation": "Design patterns are classified into three types: Creational (object creation), Structural (object composition), and Behavioral (object interaction and responsibility).",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Medium",
      "related_section": "8.5 - OOP Design and Patterns",
      "keywords": ["design pattern", "creational", "structural", "behavioral"]
    },
    {
      "id": 25,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is software maintenance?",
      "options": ["Fixing bugs", "Modification and support of software after deployment", "Hardware maintenance", "Documentation"],
      "correct_answer": "Modification and support of software after deployment",
      "hint": "Post-deployment activities",
      "explanation": "Software maintenance includes bug fixes, enhancements, adaptations to new platforms, and performance improvements after software deployment.",
      "source": "Set 3 (Asojh, 2080)",
      "difficulty": "Easy",
      "related_section": "8.1 - Software Process Models",
      "keywords": ["maintenance", "bug fix", "enhancement", "support"]
    },
    {
      "id": 26,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is system testing?",
      "options": ["Unit testing", "Testing complete integrated system against requirements", "GUI testing", "Code testing"],
      "correct_answer": "Testing complete integrated system against requirements",
      "hint": "Tests entire system as a whole",
      "explanation": "System testing tests the complete integrated system against specified requirements. It verifies that all components work together correctly.",
      "source": "Model Set",
      "difficulty": "Medium",
      "related_section": "8.3 - Testing and Quality Assurance",
      "keywords": ["system test", "requirements", "integration", "verification"]
    },
    {
      "id": 27,
      "question_type": "Short Answer",
      "marks": 1,
      "question": "What is acceptance testing?",
      "options": ["Unit testing", "End-user/customer testing to accept software", "Developer testing", "Performance testing"],
      "correct_answer": "End-user/customer testing to accept software",
      "hint": "Final approval by users",
      "explanation": "Acceptance testing (UAT) is performed by end-users/customers to determine if software meets their requirements and is acceptable for deployment.",
      "source": "Set 1 (Chaitra, 2080)",
      "difficulty": "Easy",
      "related_section": "8.3 - Testing and Quality Assurance",
      "keywords": ["acceptance test", "UAT", "user", "requirements"]
    },
    {
      "id": 28,
      "question_type": "Long Answer",
      "marks": 2,
      "question": "What is the Observer pattern?",
      "options": ["Watching code", "Behavioral pattern for notifications when state changes", "Monitoring pattern", "Testing pattern"],
      "correct_answer": "Behavioral pattern for notifications when state changes",
      "hint": "One-to-many dependency",
      "explanation": "Observer is a behavioral pattern that defines one-to-many relationship. When one object (subject) changes state, all dependent objects (observers) are notified.",
      "source": "Set 2 (Aasadh, 2081)",
      "difficulty": "Hard",
      "related_section": "8.5 - OOP Design and Patterns",
      "keywords": ["Observer", "pattern", "notification", "state change"]
    }
  ]
}
